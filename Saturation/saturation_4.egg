;; Define all registers used
(datatype Reg 
  (x0)      ; zero register
  (a2_0) 
  (a5_1) 
  (a5_2)
  (s3_0) 
  (s4_0) 
  (s4_1)
  (t0)      ; temporary registers for transformations
  (t1))

;; Immediate values
(datatype Imm (ImmVal i64))

;; Instructions as DAG nodes - each produces a value
(datatype Inst
    ;; Arithmetic
    (Add  Inst Inst)          ; rd = rs1 + rs2
    (AddI Inst Imm)           ; rd = rs1 + imm
    (Sub  Inst Inst)          ; rd = rs1 - rs2
    (SubI Inst Imm)           ; rd = rs1 - imm
    (Mul  Inst Inst)          ; rd = rs1 * rs2
    (MulH Inst Inst)          ; rd = high64(rs1 * rs2)
    (Divu Inst Inst)          ; rd = rs1 / rs2 (unsigned division)
    (Remu Inst Inst)          ; rd = rs1 % rs2 (unsigned remainder)
    
    ;; Logical operations
    (And  Inst Inst)          ; rd = rs1 & rs2
    (AndI Inst Imm)           ; rd = rs1 & imm
    (Or   Inst Inst)          ; rd = rs1 | rs2
    (OrI  Inst Imm)           ; rd = rs1 | imm
    (Xor  Inst Inst)          ; rd = rs1 ^ rs2
    (XorI Inst Imm)           ; rd = rs1 ^ imm
    
    ;; Shift operations
    (Srl  Inst Inst)          ; rd = rs1 >> rs2 (logical shift right by register)
    (SrlI Inst Imm)           ; rd = rs1 >> imm (logical shift right by immediate)
    (Sll  Inst Inst)          ; rd = rs1 << rs2 (shift left by register)
    (SllI Inst Imm)           ; rd = rs1 << imm (shift left by immediate)
    (Sra  Inst Inst)          ; rd = rs1 >>> rs2 (arithmetic shift right)
    (SraI Inst Imm)           ; rd = rs1 >>> imm
    
    ;; Memory operations
    (Lbu  Inst Imm)           ; rd = load byte unsigned from (rs1 + imm)
    (Lw   Inst Imm)           ; rd = load word from (rs1 + imm)
    (Sb   Inst Inst Imm)      ; store byte rs2 to (rs1 + imm)
    
    ;; Register/Immediate values
    (RegVal Reg)              ; Value from register
    (LoadImm Imm))            ; Load immediate value

;; Define the instruction sequence as a DAG:
;; srl a5_1,a2_0,s3_0  
;; add s4_1,s4_0,a5_1  
;; lbu a5_2,0(s4_1)

;; Step 1: srl a5_1, a2_0, s3_0
(let a5_1_val (Srl (RegVal (a2_0)) (RegVal (s3_0))))

;; Step 2: add s4_1, s4_0, a5_1
(let s4_1_val (Add (RegVal (s4_0)) a5_1_val))

;; Step 3: lbu a5_2, 0(s4_1)
(let a5_2_val (Lbu s4_1_val (ImmVal 0)))

;; Mark the final value as a root (to ensure it's computed)
(relation root (Inst))
(root a5_2_val)

;; ============================================
;; OPTIMIZATION RULES
;; ============================================

;; Constant folding
(rewrite (Add (LoadImm (ImmVal a)) (LoadImm (ImmVal b))) 
         (LoadImm (ImmVal (+ a b))))
(rewrite (Sub (LoadImm (ImmVal a)) (LoadImm (ImmVal b))) 
         (LoadImm (ImmVal (- a b))))
(rewrite (Mul (LoadImm (ImmVal a)) (LoadImm (ImmVal b))) 
         (LoadImm (ImmVal (* a b))))
(rewrite (Srl (LoadImm (ImmVal a)) (LoadImm (ImmVal b))) 
         (LoadImm (ImmVal (>> a b))))
(rewrite (Sll (LoadImm (ImmVal a)) (LoadImm (ImmVal b))) 
         (LoadImm (ImmVal (<< a b))))

;; Identity operations
(rewrite (Add v (LoadImm (ImmVal 0))) v)
(rewrite (Add (LoadImm (ImmVal 0)) v) v)
(rewrite (Sub v (LoadImm (ImmVal 0))) v)
(rewrite (Mul v (LoadImm (ImmVal 1))) v)
(rewrite (Mul (LoadImm (ImmVal 1)) v) v)
(rewrite (Divu v (LoadImm (ImmVal 1))) v)
(rewrite (Srl v (LoadImm (ImmVal 0))) v)
(rewrite (Sll v (LoadImm (ImmVal 0))) v)

;; Zero operations
(rewrite (Mul v (LoadImm (ImmVal 0))) (LoadImm (ImmVal 0)))
(rewrite (Mul (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (And v (LoadImm (ImmVal 0))) (LoadImm (ImmVal 0)))
(rewrite (And (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))

;; Algebraic simplifications
(rewrite (Add v1 v2) (Add v2 v1))              ; Commutativity of addition
(rewrite (Mul v1 v2) (Mul v2 v1))              ; Commutativity of multiplication
(rewrite (Sub v (RegVal (x0))) v)              ; v - 0 = v
(rewrite (Sub v v) (LoadImm (ImmVal 0)))       ; v - v = 0
(rewrite (Xor v v) (LoadImm (ImmVal 0)))       ; v ^ v = 0
(rewrite (Sub (LoadImm (ImmVal 0)) v) (Sub (RegVal (x0)) v))  ; 0 - v = -v

;; ============================================
;; NEW REWRITE RULE 1: Add using two Subs
;; a + b = a - (0 - b)
;; ============================================
(rewrite (Add a b) 
         (Sub a (Sub (LoadImm (ImmVal 0)) b)))

;; Alternative: a + b = a - (-b) if we had negation
;; But since we're working with unsigned, the above is more appropriate

;; ============================================
;; NEW REWRITE RULE 2: Emulate Srl using division
;; srl x2, x1, x3 â‰¡ x2 = x1 / (1 << x3)
;; ============================================
(rewrite (Srl x1 x3)
         (Divu x1 (Sll (LoadImm (ImmVal 1)) x3)))

;; Also for immediate shift amounts
(rewrite (SrlI x1 (ImmVal n))
         (Divu x1 (LoadImm (ImmVal (<< 1 n)))))

;; ============================================
;; SUBTRACTION REWRITE RULE
;; sub xD, x1, x2 -> xori t0,x2,-1; addi t0,t0,1; add xD,x1,t0
;; This implements: x1 - x2 = x1 + (~x2 + 1) [two's complement]
;; ============================================
(rewrite (Sub x1 x2)
         (Add x1 (AddI (XorI x2 (ImmVal -1)) (ImmVal 1))))

;; ============================================
;; Reverse transformations (for exploration)
;; ============================================
;; Division by power of 2 can become shift
(rewrite (Divu x (LoadImm (ImmVal 2))) (SrlI x (ImmVal 1)))
(rewrite (Divu x (LoadImm (ImmVal 4))) (SrlI x (ImmVal 2)))
(rewrite (Divu x (LoadImm (ImmVal 8))) (SrlI x (ImmVal 3)))
(rewrite (Divu x (LoadImm (ImmVal 16))) (SrlI x (ImmVal 4)))
(rewrite (Divu x (LoadImm (ImmVal 32))) (SrlI x (ImmVal 5)))

;; Multiplication by power of 2 can become shift
(rewrite (Mul v (LoadImm (ImmVal 2))) (SllI v (ImmVal 1)))
(rewrite (Mul v (LoadImm (ImmVal 4))) (SllI v (ImmVal 2)))
(rewrite (Mul v (LoadImm (ImmVal 8))) (SllI v (ImmVal 3)))
(rewrite (Mul v (LoadImm (ImmVal 16))) (SllI v (ImmVal 4)))
(rewrite (Mul v (LoadImm (ImmVal 32))) (SllI v (ImmVal 5)))

;; ============================================
;; Strength reduction
;; ============================================
;; Multiply by -1 is negation
(rewrite (Mul v (LoadImm (ImmVal -1))) (Sub (LoadImm (ImmVal 0)) v))

;; Division identities
(rewrite (Divu (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))  ; 0 / v = 0

;; Associativity rules
(rewrite (Add (Add a b) c) (Add a (Add b c)))
(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))

;; Distribution (optional - may increase expression size)
; (rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
; (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))  ; factoring

;; ============================================
;; Address calculation optimizations
;; ============================================
(rewrite (Lbu (Add base (LoadImm (ImmVal 0))) (ImmVal off))
         (Lbu base (ImmVal off)))

;; ============================================
;; Test the transformations
;; ============================================

; ;; Test 1: Can we transform add to sub-based implementation?
; (let test_add (Add (RegVal (a2_0)) (RegVal (s3_0))))
; (let test_add_as_sub (Sub (RegVal (a2_0)) (Sub (LoadImm (ImmVal 0)) (RegVal (s3_0)))))

; ;; Test 2: Can we transform srl to division-based implementation?
; (let test_srl (Srl (RegVal (a2_0)) (RegVal (s3_0))))
; (let test_srl_as_div (Divu (RegVal (a2_0)) (Sll (LoadImm (ImmVal 1)) (RegVal (s3_0)))))

;; Run optimization
(run 20)