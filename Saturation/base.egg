;; ============================================
;; BASE.EGG - Shared RV32IM ISA Definitions
;; ============================================
;; This file contains:
;; 1. Complete RV32IM instruction set definitions
;; 2. Common data types (immediates)
;; 3. Standard rewrite rules for optimization
;; ============================================
;; Note: Registers are declared per-block in SSA form

;; ============================================
;; DATA TYPES
;; ============================================

;; Immediate values
(datatype Imm (ImmVal i64))

;; ============================================
;; RV32I BASE INTEGER INSTRUCTIONS
;; ============================================

(datatype Inst
    ;; === Immediate Instructions (U-type) ===
    (Lui   Imm)               ; rd = imm << 12
    (Auipc Imm)               ; rd = PC + (imm << 12)

    ;; === Jump Instructions ===
    (Jal   Imm)               ; rd = PC + 4; PC = PC + offset
    (Jalr  Inst Imm)          ; rd = PC + 4; PC = (rs1 + offset) & ~1

    ;; === Branch Instructions (B-type) ===
    (Beq   Inst Inst Imm)    ; if (rs1 == rs2) PC += offset
    (Bne   Inst Inst Imm)    ; if (rs1 != rs2) PC += offset
    (Blt   Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (signed)
    (Bge   Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (signed)
    (Bltu  Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (unsigned)
    (Bgeu  Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (unsigned)

    ;; === Load Instructions (I-type) ===
    (Lb    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][7:0])
    (Lh    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][15:0])
    (Lw    Inst Imm)          ; rd = M[rs1 + offset][31:0]
    (Lbu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][7:0])
    (Lhu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][15:0])

    ;; === Store Instructions (S-type) ===
    (Sb    Inst Inst Imm)     ; M[rs1 + offset][7:0] = rs2[7:0]
    (Sh    Inst Inst Imm)     ; M[rs1 + offset][15:0] = rs2[15:0]
    (Sw    Inst Inst Imm)     ; M[rs1 + offset][31:0] = rs2[31:0]

    ;; === Register-Immediate Arithmetic/Logical (I-type) ===
    (Addi  Inst Imm)          ; rd = rs1 + imm
    (Slti  Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (signed)
    (Sltiu Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (unsigned)
    (Xori  Inst Imm)          ; rd = rs1 ^ imm
    (Ori   Inst Imm)          ; rd = rs1 | imm
    (Andi  Inst Imm)          ; rd = rs1 & imm
    (Slli  Inst Imm)          ; rd = rs1 << shamt
    (Srli  Inst Imm)          ; rd = rs1 >> shamt (logical)
    (Srai  Inst Imm)          ; rd = rs1 >> shamt (arithmetic)

    ;; === Register-Register Arithmetic/Logical (R-type) ===
    (Add   Inst Inst)         ; rd = rs1 + rs2
    (Sub   Inst Inst)         ; rd = rs1 - rs2
    (Sll   Inst Inst)         ; rd = rs1 << rs2[4:0]
    (Slt   Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (signed)
    (Sltu  Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (unsigned)
    (Xor   Inst Inst)         ; rd = rs1 ^ rs2
    (Srl   Inst Inst)         ; rd = rs1 >> rs2[4:0] (logical)
    (Sra   Inst Inst)         ; rd = rs1 >> rs2[4:0] (arithmetic)
    (Or    Inst Inst)         ; rd = rs1 | rs2
    (And   Inst Inst)         ; rd = rs1 & rs2

    ;; === Memory Ordering ===
    (Fence Imm Imm)           ; Memory fence
    (FenceI)                  ; Instruction fence

    ;; === System Instructions ===
    (Ecall)                   ; Environment call
    (Ebreak)                  ; Environment breakpoint
    (Pause)                   ; Pause hint

    ;; ============================================
    ;; RV32M MULTIPLICATION/DIVISION EXTENSION
    ;; ============================================

    (Mul    Inst Inst)        ; rd = (rs1 * rs2)[31:0]
    (Mulh   Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × signed)
    (Mulhsu Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × unsigned)
    (Mulhu  Inst Inst)        ; rd = (rs1 * rs2)[63:32] (unsigned × unsigned)
    (Div    Inst Inst)        ; rd = rs1 / rs2 (signed)
    (Divu   Inst Inst)        ; rd = rs1 / rs2 (unsigned)
    (Rem    Inst Inst)        ; rd = rs1 % rs2 (signed)
    (Remu   Inst Inst)        ; rd = rs1 % rs2 (unsigned)

    ;; === Special Values ===
    (LoadImm Imm)             ; Load immediate value
    (RegVal Reg) 
    (Nop))                    ; No operation

;; ============================================
;; STANDARD OPTIMIZATION RULES
;; ============================================

;; === Constant Folding ===
(rewrite (Add (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (+ a b))))
(rewrite (Sub (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (- a b))))
(rewrite (Mul (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (* a b))))
(rewrite (And (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (& a b))))
(rewrite (Or  (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (| a b))))
(rewrite (Xor (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (^ a b))))
(rewrite (Sll (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (<< a b))))
(rewrite (Srl (LoadImm (ImmVal a)) (LoadImm (ImmVal b)))
         (LoadImm (ImmVal (>> a b))))

;; === Identity Operations ===
(rewrite (Add v (LoadImm (ImmVal 0))) v)
(rewrite (Add (LoadImm (ImmVal 0)) v) v)
(rewrite (Sub v (LoadImm (ImmVal 0))) v)
(rewrite (Or  v (LoadImm (ImmVal 0))) v)
(rewrite (Or  (LoadImm (ImmVal 0)) v) v)
(rewrite (Xor v (LoadImm (ImmVal 0))) v)
(rewrite (Xor (LoadImm (ImmVal 0)) v) v)
(rewrite (Mul v (LoadImm (ImmVal 1))) v)
(rewrite (Mul (LoadImm (ImmVal 1)) v) v)
(rewrite (Div v (LoadImm (ImmVal 1))) v)
(rewrite (Divu v (LoadImm (ImmVal 1))) v)
;; Shift by zero (immediate versions)
(rewrite (Slli v (ImmVal 0)) v)
(rewrite (Srli v (ImmVal 0)) v)
(rewrite (Srai v (ImmVal 0)) v)

;; === Zero Operations ===
(rewrite (Mul v (LoadImm (ImmVal 0))) (LoadImm (ImmVal 0)))
(rewrite (Mul (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (And v (LoadImm (ImmVal 0))) (LoadImm (ImmVal 0)))
(rewrite (And (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (Div (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (Divu (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (Rem (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))
(rewrite (Remu (LoadImm (ImmVal 0)) v) (LoadImm (ImmVal 0)))

;; === All-Ones Operations ===
(rewrite (And v (LoadImm (ImmVal -1))) v)
(rewrite (And (LoadImm (ImmVal -1)) v) v)
(rewrite (Or v (LoadImm (ImmVal -1))) (LoadImm (ImmVal -1)))
(rewrite (Or (LoadImm (ImmVal -1)) v) (LoadImm (ImmVal -1)))

;; === Self Operations ===
(rewrite (Sub v v) (LoadImm (ImmVal 0)))
(rewrite (Xor v v) (LoadImm (ImmVal 0)))
(rewrite (And v v) v)
(rewrite (Or v v) v)

;; === Commutativity ===
(rewrite (Add v1 v2) (Add v2 v1))
(rewrite (Mul v1 v2) (Mul v2 v1))
(rewrite (And v1 v2) (And v2 v1))
(rewrite (Or v1 v2) (Or v2 v1))
(rewrite (Xor v1 v2) (Xor v2 v1))

;; === Associativity ===
(rewrite (Add (Add a b) c) (Add a (Add b c)))
(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))
(rewrite (And (And a b) c) (And a (And b c)))
(rewrite (Or (Or a b) c) (Or a (Or b c)))
(rewrite (Xor (Xor a b) c) (Xor a (Xor b c)))

;; === Strength Reduction ===
;; Multiplication by powers of 2 -> shifts
(rewrite (Mul v (LoadImm (ImmVal 2))) (Slli v (ImmVal 1)))
(rewrite (Mul v (LoadImm (ImmVal 4))) (Slli v (ImmVal 2)))
(rewrite (Mul v (LoadImm (ImmVal 8))) (Slli v (ImmVal 3)))
(rewrite (Mul v (LoadImm (ImmVal 16))) (Slli v (ImmVal 4)))
(rewrite (Mul v (LoadImm (ImmVal 32))) (Slli v (ImmVal 5)))
(rewrite (Mul v (LoadImm (ImmVal 64))) (Slli v (ImmVal 6)))
(rewrite (Mul v (LoadImm (ImmVal 128))) (Slli v (ImmVal 7)))
(rewrite (Mul v (LoadImm (ImmVal 256))) (Slli v (ImmVal 8)))
(rewrite (Mul (LoadImm (ImmVal 2)) v) (Slli v (ImmVal 1)))
(rewrite (Mul (LoadImm (ImmVal 4)) v) (Slli v (ImmVal 2)))
(rewrite (Mul (LoadImm (ImmVal 8)) v) (Slli v (ImmVal 3)))
(rewrite (Mul (LoadImm (ImmVal 16)) v) (Slli v (ImmVal 4)))

;; Division by powers of 2 -> shifts (unsigned)
(rewrite (Divu v (LoadImm (ImmVal 2))) (Srli v (ImmVal 1)))
(rewrite (Divu v (LoadImm (ImmVal 4))) (Srli v (ImmVal 2)))
(rewrite (Divu v (LoadImm (ImmVal 8))) (Srli v (ImmVal 3)))
(rewrite (Divu v (LoadImm (ImmVal 16))) (Srli v (ImmVal 4)))
(rewrite (Divu v (LoadImm (ImmVal 32))) (Srli v (ImmVal 5)))
(rewrite (Divu v (LoadImm (ImmVal 64))) (Srli v (ImmVal 6)))
(rewrite (Divu v (LoadImm (ImmVal 128))) (Srli v (ImmVal 7)))
(rewrite (Divu v (LoadImm (ImmVal 256))) (Srli v (ImmVal 8)))

;; Multiplication by -1 is negation
(rewrite (Mul v (LoadImm (ImmVal -1))) (Sub (LoadImm (ImmVal 0)) v))
(rewrite (Mul (LoadImm (ImmVal -1)) v) (Sub (LoadImm (ImmVal 0)) v))

;; === Instruction Decomposition ===

;; Double shifts for larger shift amounts (example for constant propagation)
(rewrite (Slli v (ImmVal 4))
         (Slli (Slli v (ImmVal 2)) (ImmVal 2)))
(rewrite (Slli v (ImmVal 6))
         (Slli (Slli v (ImmVal 3)) (ImmVal 3)))
(rewrite (Srli v (ImmVal 4))
         (Srli (Srli v (ImmVal 2)) (ImmVal 2)))
(rewrite (Srai v (ImmVal 4))
         (Srai (Srai v (ImmVal 2)) (ImmVal 2)))

;; Subtraction using two's complement: a - b = a + (~b + 1)
(rewrite (Sub x1 x2)
         (Add x1 (Addi (Xori x2 (ImmVal -1)) (ImmVal 1))))

;; === Comparison Optimizations ===
(rewrite (Slt v v) (LoadImm (ImmVal 0)))   ; v < v is always false
(rewrite (Sltu v v) (LoadImm (ImmVal 0)))  ; v < v is always false (unsigned)

;; === Load/Store Optimizations ===
;; Combine adjacent loads/stores with same base
;; Note: These are examples - actual optimizations would need aliasing analysis

;; === Branch Simplifications ===
;; Branch on same values
(rewrite (Beq v v target) (Jal target))    ; Always taken
(rewrite (Bne v v target) (Nop))           ; Never taken
(rewrite (Blt v v target) (Nop))           ; Never taken
(rewrite (Bge v v target) (Jal target))    ; Always taken

;; === De Morgan's Laws ===
(rewrite (Xori (And a b) (ImmVal -1))
         (Or (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))
(rewrite (Xori (Or a b) (ImmVal -1))
         (And (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))

;; === Distribution (optional - increases expression size) ===
;; Uncomment if needed for specific optimizations
;; (rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
;; (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))  ; factoring

;; === Boolean simplifications ===
(rewrite (And (Or a b) (Or a c))
         (Or a (And b c)))
(rewrite (Or (And a b) (And a c))
         (And a (Or b c)))

;; === Double negation ===
(rewrite (Sub (LoadImm (ImmVal 0)) (Sub (LoadImm (ImmVal 0)) v))
         v)

;; === Modulo by power of 2 -> AND with mask ===
(rewrite (Remu v (LoadImm (ImmVal 2))) (Andi v (ImmVal 1)))
(rewrite (Remu v (LoadImm (ImmVal 4))) (Andi v (ImmVal 3)))
(rewrite (Remu v (LoadImm (ImmVal 8))) (Andi v (ImmVal 7)))
(rewrite (Remu v (LoadImm (ImmVal 16))) (Andi v (ImmVal 15)))
(rewrite (Remu v (LoadImm (ImmVal 32))) (Andi v (ImmVal 31)))

;; === Bit manipulation patterns ===
;; Set lowest bit: x | 1
;; Clear lowest bit: x & ~1
;; Toggle lowest bit: x ^ 1
;; Check if even: (x & 1) == 0
;; Check if odd: (x & 1) == 1

;; === Min/Max patterns (using branches) ===
;; max(a, b) = (a >= b) ? a : b
;; min(a, b) = (a < b) ? a : b

;; === Absolute value (for signed) ===
;; abs(x) = (x < 0) ? -x : x
;; Which becomes: (x < 0) ? (0 - x) : x

;; End of base.egg