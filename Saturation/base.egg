;; ============================================
;; BASE.EGG - Shared RV32IM ISA Definitions
;; ============================================
;; This file contains:
;; 1. Complete RV32IM instruction set definitions
;; 2. Common data types (immediates)
;; 3. Standard rewrite rules for optimization
;; ============================================
;; Note: Registers are declared per-block in SSA form

;; ============================================
;; DATA TYPES
;; ============================================

;; Immediate values
(datatype Imm (ImmVal i64) (ImmLabel String))
;; ============================================
;; RV32I BASE INTEGER INSTRUCTIONS
;; ============================================

(datatype Inst
    ;; === Immediate Instructions (U-type) ===
    (Lui   Imm)               ; rd = imm << 12
    (Auipc Imm)               ; rd = PC + (imm << 12)

    ;; === Jump Instructions ===
    (Jal   Imm)               ; rd = PC + 4; PC = PC + offset
    (Jalr  Inst Imm)          ; rd = PC + 4; PC = (rs1 + offset) & ~1

    ;; === Branch Instructions (B-type) ===
    (Beq   Inst Inst Imm)    ; if (rs1 == rs2) PC += offset
    (Bne   Inst Inst Imm)    ; if (rs1 != rs2) PC += offset
    (Blt   Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (signed)
    (Bge   Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (signed)
    (Bltu  Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (unsigned)
    (Bgeu  Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (unsigned)

    ;; === Load Instructions (I-type) ===
    (Lb    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][7:0])
    (Lh    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][15:0])
    (Lw    Inst Imm)          ; rd = M[rs1 + offset][31:0]
    (Lbu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][7:0])
    (Lhu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][15:0])

    ;; === Store Instructions (S-type) ===
    (Sb    Inst Inst Imm)     ; M[rs1 + offset][7:0] = rs2[7:0]
    (Sh    Inst Inst Imm)     ; M[rs1 + offset][15:0] = rs2[15:0]
    (Sw    Inst Inst Imm)     ; M[rs1 + offset][31:0] = rs2[31:0]

    ;; === Register-Immediate Arithmetic/Logical (I-type) ===
    (Addi  Inst Imm)          ; rd = rs1 + imm
    (Slti  Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (signed)
    (Sltiu Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (unsigned)
    (Xori  Inst Imm)          ; rd = rs1 ^ imm
    (Ori   Inst Imm)          ; rd = rs1 | imm
    (Andi  Inst Imm)          ; rd = rs1 & imm
    (Slli  Inst Imm)          ; rd = rs1 << shamt
    (Srli  Inst Imm)          ; rd = rs1 >> shamt (logical)
    (Srai  Inst Imm)          ; rd = rs1 >> shamt (arithmetic)

    ;; === Register-Register Arithmetic/Logical (R-type) ===
    (Add   Inst Inst)         ; rd = rs1 + rs2
    (Sub   Inst Inst)         ; rd = rs1 - rs2
    (Sll   Inst Inst)         ; rd = rs1 << rs2[4:0]
    (Slt   Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (signed)
    (Sltu  Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (unsigned)
    (Xor   Inst Inst)         ; rd = rs1 ^ rs2
    (Srl   Inst Inst)         ; rd = rs1 >> rs2[4:0] (logical)
    (Sra   Inst Inst)         ; rd = rs1 >> rs2[4:0] (arithmetic)
    (Or    Inst Inst)         ; rd = rs1 | rs2
    (And   Inst Inst)         ; rd = rs1 & rs2

    ;; === Memory Ordering ===
    (Fence Imm Imm)           ; Memory fence
    (FenceI)                  ; Instruction fence

    ;; === System Instructions ===
    (Ecall)                   ; Environment call
    (Ebreak)                  ; Environment breakpoint
    (Pause)                   ; Pause hint

    ;; ============================================
    ;; RV32M MULTIPLICATION/DIVISION EXTENSION
    ;; ============================================

    (Mul    Inst Inst)        ; rd = (rs1 * rs2)[31:0]
    (Mulh   Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × signed)
    (Mulhsu Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × unsigned)
    (Mulhu  Inst Inst)        ; rd = (rs1 * rs2)[63:32] (unsigned × unsigned)
    (Div    Inst Inst)        ; rd = rs1 / rs2 (signed)
    (Divu   Inst Inst)        ; rd = rs1 / rs2 (unsigned)
    (Rem    Inst Inst)        ; rd = rs1 % rs2 (signed)
    (Remu   Inst Inst)        ; rd = rs1 % rs2 (unsigned)

    ;; === Special Values ===
    (LoadImm Imm)             ; Load immediate value
    (RegVal String)           ; Register value reference (takes register name as string)
    (Nop)                     ; No operation

    ;; === Instruction Sequences ===
    ;; Seq2 allows rewriting single instructions as 2-instruction sequences
    ;; Longer sequences can be built by nesting: Seq2(a, Seq2(b, Seq2(c, d)))
    (Seq2 Inst Inst)          ; Sequence of 2 instructions
    
    ;; === Subroutine caller ===
    (CallMul Inst Inst)
    (CallDiv Inst Inst)
    (CallDivu Inst Inst)
    (CallRem Inst Inst)
    (CallRemu Inst Inst)
    )         

;; ============================================
;; STANDARD OPTIMIZATION RULES
;; ============================================


;; Shift by zero (immediate versions)
(rewrite (Slli v (ImmVal 0)) v)
(rewrite (Srli v (ImmVal 0)) v)
(rewrite (Srai v (ImmVal 0)) v)

;; === Instruction Decomposition ===

;; Double shifts for larger shift amounts (example for constant propagation)
(rewrite (Slli v (ImmVal 4))
        (Slli (Slli v (ImmVal 2)) (ImmVal 2)))
;;(rewrite (Slli v (ImmVal 6))
;;         (Slli (Slli v (ImmVal 3)) (ImmVal 3)))
;;(rewrite (Srli v (ImmVal 4))
;;         (Srli (Srli v (ImmVal 2)) (ImmVal 2)))
;;(rewrite (Srai v (ImmVal 4))
;;         (Srai (Srai v (ImmVal 2)) (ImmVal 2)))

;; === Load/Store Optimizations ===
;; Decompose byte and halfword loads/stores to use only LW/SW
;; This allows hardware to implement only word-size memory operations

;; VERIFIED: Works for full RISC-V range (-2048 to +2047)

;; BYTE LOAD ALIGNMENT (LB, LBU)
;; ============================================

; (function align-down (i64) i64 :merge (min old new))
; (function byte-offset (i64) i64 :merge (min old new))

; ;; Compute aligned address: off & ~3
; (rule ((= inst (Lbu base (ImmVal off))))
;       ((set (align-down off) (& off (not-i64 3)))))
; (rule ((= inst (Lb base (ImmVal off))))
;       ((set (align-down off) (& off (not-i64 3)))))

; ;; Compute byte position shift: ((off % 4) + 4) % 4 * 8
; ;; CRITICAL: Mathematical modulo for negative offset support
; (rule ((= inst (Lbu base (ImmVal off))))
;       ((set (byte-offset off) (* (% (+ (% off 4) 4) 4) 8))))
; (rule ((= inst (Lb base (ImmVal off))))
;       ((set (byte-offset off) (* (% (+ (% off 4) 4) 4) 8))))

; ;; Load Byte Unsigned: LBU = LW + shift + mask
; (rewrite (Lbu base (ImmVal off))
;          (Andi (Srli (Lw base (ImmVal aligned))
;                      (ImmVal shift))
;                (ImmVal 255))
;          :when ((= aligned (align-down off))
;                 (= shift (byte-offset off))))

; ;; Load Byte Signed: LB = LW + shift + sign extension
; (rewrite (Lb base (ImmVal off))
;          (Srai (Slli (Srli (Lw base (ImmVal aligned))
;                            (ImmVal shift))
;                      (ImmVal 24))
;                (ImmVal 24))
;          :when ((= aligned (align-down off))
;                 (= shift (byte-offset off))))

; ;; ============================================
; ;; HALFWORD LOAD ALIGNMENT (LH, LHU)
; ;; ============================================

; (function align-down-half (i64) i64 :merge (min old new))
; (function half-offset (i64) i64 :merge (min old new))

; ;; Compute aligned address: off & ~3
; (rule ((= inst (Lhu base (ImmVal off))))
;       ((set (align-down-half off) (& off (not-i64 3)))))
; (rule ((= inst (Lh base (ImmVal off))))
;       ((set (align-down-half off) (& off (not-i64 3)))))

; ;; Compute halfword position shift: ((off/2 % 2) + 2) % 2 * 16
; ;; CRITICAL: Mathematical modulo for negative offset support
; (rule ((= inst (Lhu base (ImmVal off))))
;       ((set (half-offset off) (* (% (+ (% (/ off 2) 2) 2) 2) 16))))
; (rule ((= inst (Lh base (ImmVal off))))
;       ((set (half-offset off) (* (% (+ (% (/ off 2) 2) 2) 2) 16))))

; ;; Load Halfword Unsigned: LHU = LW + shift + mask
; (rewrite (Lhu base (ImmVal off))
;          (Andi (Srli (Lw base (ImmVal aligned))
;                      (ImmVal shift))
;                (ImmVal 65535))
;          :when ((= aligned (align-down-half off))
;                 (= shift (half-offset off))))

; ;; Load Halfword Signed: LH = LW + shift + sign extension
; (rewrite (Lh base (ImmVal off))
;          (Srai (Slli (Srli (Lw base (ImmVal aligned))
;                            (ImmVal shift))
;                      (ImmVal 16))
;                (ImmVal 16))
;          :when ((= aligned (align-down-half off))
;                 (= shift (half-offset off))))


;; Store Word decomposition: SW = 4× SB (simpler than RMW approach)
;; SW stores 4 bytes sequentially using SB (assumes little-endian)
;; Example: SW value, 0(base) = SB byte0; SB byte1; SB byte2; SB byte3
;;
;; Using nested Seq2:
;; (rewrite (Sw base value (ImmVal 0))
;;            (Seq2 (Sb base (Andi value (ImmVal 255)) (ImmVal 0))
;;                  (Seq2 (Sb base (Andi (Srli value (ImmVal 8)) (ImmVal 255)) (ImmVal 1))
;;                        (Seq2 (Sb base (Andi (Srli value (ImmVal 16)) (ImmVal 255)) (ImmVal 2))
;;                              (Sb base (Srli value (ImmVal 24)) (ImmVal 3))))))
;;
;; Store Halfword decomposition: SH = 2× SB
;; (rewrite (Sh base value (ImmVal 0))
;;            (Seq2 (Sb base (Andi value (ImmVal 255)) (ImmVal 0))
;;                  (Sb base (Andi (Srli value (ImmVal 8)) (ImmVal 255)) (ImmVal 1))))
;;
;; Note: Currently commented out - full implementation requires offset arithmetic
;; and would only work for constant offsets (ImmVal), not symbolic (ImmLabel)


;; Lbu with aligned offset → Lw + mask (works even if base is unaligned on Ibex)
(rewrite (Lbu base (ImmVal 0))
      (Andi (Lw base (ImmVal 0)) (ImmVal 255)))

(rewrite (Lbu base (ImmVal 4))
      (Andi (Lw base (ImmVal 4)) (ImmVal 255)))

;; Lh offset 0 → Lw + sign extend
(rewrite (Lh base (ImmVal 0))
      (Srai (Slli (Lw base (ImmVal 0)) (ImmVal 16)) (ImmVal 16)))

;; Lhu offset 0 → Lw + zero extend (use shifts, not Andi 65535)
(rewrite (Lhu base (ImmVal 0))
      (Srli (Slli (Lw base (ImmVal 0)) (ImmVal 16)) (ImmVal 16)))


;; ============================================
;; I-type Decomposition: Use Only ADDI + R-type
;; ============================================
;; All I-type instructions except ADDI can be implemented using:
;;   - ADDI to load immediate (Addi x0 imm produces the immediate value)
;;   - R-type operation using that value
;; This allows hardware to omit 8 I-type decoders, keeping only ADDI
;;
;; Note: Addi signature is (Addi Inst Imm), so Addi(x0, imm) loads imm

;; XORI rd, rs, imm  =  xor rd, rs, (addi x0, imm)
(rewrite (Xori rs imm)
           (Xor rs (Addi (RegVal "x0") imm)))

;; ANDI rd, rs, imm  =  and rd, rs, (addi x0, imm)
(rewrite (Andi rs imm)
           (And rs (Addi (RegVal "x0") imm)))

;; ORI rd, rs, imm  =  or rd, rs, (addi x0, imm)
(rewrite (Ori rs imm)
           (Or rs (Addi (RegVal "x0") imm)))

;; SLTI rd, rs, imm  =  slt rd, rs, (addi x0, imm)
(rewrite (Slti rs imm)
           (Slt rs (Addi (RegVal "x0") imm)))

;; SLTIU rd, rs, imm  =  sltu rd, rs, (addi x0, imm)
(rewrite (Sltiu rs imm)
           (Sltu rs (Addi (RegVal "x0") imm)))

;; SLLI rd, rs, imm  =  sll rd, rs, (addi x0, imm)
(rewrite (Slli rs imm)
           (Sll rs (Addi (RegVal "x0") imm)))

;; SRLI rd, rs, imm  =  srl rd, rs, (addi x0, imm)
(rewrite (Srli rs imm)
           (Srl rs (Addi (RegVal "x0") imm)))

;; SRAI rd, rs, imm  =  sra rd, rs, (addi x0, imm)
(rewrite (Srai rs imm)
           (Sra rs (Addi (RegVal "x0") imm)))

;; ============================================
;; LUI Decomposition (Commented - Too Complex)
;; ============================================
;; LUI can be eliminated by loading 32-bit constants using shift-and-add sequences
;; Example: Load 0xABCDE000 (LUI loads upper 20 bits, lower 12 are 0)
;;
;; Method: Break constant into chunks, shift and add iteratively
;;   addi sft, x0, 12         ; Shift amount = 12 bits
;;   addi foo, x0, 0xABC      ; Load high 12 bits [31:20]
;;   sll  foo, foo, sft       ; Shift left 12
;;   addi foo, foo, 0xDE0     ; Add middle bits [19:8]
;;   sll  foo, foo, sft       ; Shift left 12 again
;;   addi foo, foo, 0x000     ; Add low bits [7:0]
;;
;; Requires 6 instructions vs 1 LUI (3x cost increase)
;; Pattern would need:
;;   - Constant splitting (can't express in egglog patterns)
;;   - Complex nested Seq2 (5 levels deep)
;;   - Only works for ImmVal, not ImmLabel
;;
;; Alternative: Use constant pool + LW (like ARM)
;;   jal ra, next
;; next: lw rd, const_pool_offset(ra)
;;
;; Conclusion: LUI removal saves very little area, adds significant complexity
;; Recommendation: Keep LUI in hardware

;; ============================================
;; SLT/SLTU Decomposition Using Branches
;; ============================================
;; Set-less-than can be implemented using branch instructions
;; Pattern: Assume true (1), branch-skip-if-true, set false (0)
;;
;; slt a, b, c becomes:
;;   addi a, x0, 1      ; Assume result = 1 (true)
;;   blt b, c, .+4      ; If b < c, skip next instruction
;;   addi a, x0, 0      ; Result = 0 (false, only executed if branch not taken)
;;
;; Uses Seq2 because these are sequential with strict ordering (control flow)

;; SLT rd, rs1, rs2  =  blt rs1, rs2, +12; addi rd, x0, 0; jal x0, +8; addi rd, x0, 1
(rewrite (Slt rs1 rs2)
           (Seq2 (Blt rs1 rs2 (ImmVal 12))
                 (Seq2 (Addi (RegVal "x0") (ImmVal 0))
                       (Seq2 (Jal (ImmVal 8))
                             (Addi (RegVal "x0") (ImmVal 1))))))

;; SLTU rd, rs1, rs2  =  bltu rs1, rs2, +12; addi tmp, x0, 0; jal x0, +8; addi tmp, x0, 1
(rewrite (Sltu rs1 rs2)
           (Seq2 (Bltu rs1 rs2 (ImmVal 12))
                 (Seq2 (Addi (RegVal "x0") (ImmVal 0))
                       (Seq2 (Jal (ImmVal 8))
                             (Addi (RegVal "x0") (ImmVal 1))))))

;; === Branch Simplifications ===
;; Branch on same values
(rewrite (Beq v v target) (Jal target))    ; Always taken
(rewrite (Bne v v target) (Nop))           ; Never taken
(rewrite (Blt v v target) (Nop))           ; Never taken
(rewrite (Bge v v target) (Jal target))    ; Always taken
(rewrite (Bltu v v target) (Nop))          ; Never taken (unsigned)
(rewrite (Bgeu v v target) (Jal target))   ; Always taken (unsigned)

;; === Branch Sequence Rewrites ===
;; These show how branch instructions can be implemented as 2-instruction sequences
;; Both sides are Inst (Seq2 is now an Inst constructor), so no type mismatch
;; Note: Offset is 8 bytes (skip branch itself + jal instruction)

;; beq a, b, target  <==>  bne a, b, 8; jal target
;; "If equal, jump to target" <==> "If not equal, skip next inst; jump to target"
(rewrite (Beq a b target)
           (Seq2 (Bne a b (ImmVal 8)) (Jal target)))

;; bne a, b, target  <==>  beq a, b, 8; jal target
;; "If not equal, jump to target" <==> "If equal, skip next inst; jump to target"
(rewrite (Bne a b target)
           (Seq2 (Beq a b (ImmVal 8)) (Jal target)))

;; blt a, b, target  <==>  bge a, b, 8; jal target
(rewrite (Blt a b target)
           (Seq2 (Bge a b (ImmVal 8)) (Jal target)))

;; bge a, b, target  <==>  blt a, b, 8; jal target
(rewrite (Bge a b target)
           (Seq2 (Blt a b (ImmVal 8)) (Jal target)))

;; bltu a, b, target  <==>  bgeu a, b, 8; jal target
(rewrite (Bltu a b target)
           (Seq2 (Bgeu a b (ImmVal 8)) (Jal target)))

;; bgeu a, b, target  <==>  bltu a, b, 8; jal target
(rewrite (Bgeu a b target)
           (Seq2 (Bltu a b (ImmVal 8)) (Jal target)))

;; === De Morgan's Laws ===
;;(rewrite (Xori (And a b) (ImmVal -1))
;;         (Or (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))
;;(rewrite (Xori (Or a b) (ImmVal -1))
;;         (And (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))

;; Or(a,b) = (a ^ b) ^ (a & b)
(rewrite (Or a b)
         (Xor (Xor a b)
              (And a b)))
;; And(a,b) = (a | b) ^ (a ^ b)
(rewrite (And a b)
         (Xor (Or a b)
              (Xor a b)))

;; === Distribution (optional - increases expression size) ===
;; Uncomment if needed for specific optimizations
;; (rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
;; (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))  ; factoring

;; === Boolean simplifications ===
;;(rewrite (And (Or a b) (Or a c))
;;         (Or a (And b c)))
;;(rewrite (Or (And a b) (And a c))
;;         (And a (Or b c)))

;; ============================================================
;; INJECTED GREENTHUMB REWRITE RULES
;; ============================================================

;; ============================================================
;; Greenthumb-Generated Rewrite Rules
;; Auto-generated from riscv_greenthumb synthesis results
;; ============================================================

;; ============================================================
;; ADD Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     sub rd=x2 rs1=x0 rs2=x2
;;   2.     sub rd=x1 rs1=x3 rs2=x2
(rewrite (Add rs1 rs2)
           (Sub rs2 (Sub (RegVal "x0") rs1)))

;; ============================================================
;; ADDI Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     ori rd=x1 rs1=x0 imm=5
;;   2.     add rd=x1 rs1=x2 rs2=x1
(rewrite (Addi rs1 imm)
           (Add rs1 (Ori (RegVal "x0") imm)))

;; ============================================================
;; AND Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x2 rs2=x3
;;   2.     sub rd=x3 rs1=x1 rs2=x3
;;   3.     sub rd=x1 rs1=x2 rs2=x3
(rewrite (And rs1 rs2)
           (Sub rs1 (Sub (Or rs1 rs2) rs2)))

;; ============================================================
;; ANDI Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     addi rd=x1 rs1=x0 imm=5
;;   2.     and rd=x1 rs1=x1 rs2=x2
(rewrite (Andi rs1 imm)
           (And (Addi (RegVal "x0") imm) rs1))

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     xori rd=x1 rs1=x2 imm=5
;;   2.     or rd=x2 rs1=x2 rs2=x1
;;   3.     xor rd=x1 rs1=x1 rs2=x2
(rewrite (Andi rs1 imm)
           (Xor (Xori rs1 imm) (Or rs1 (Xori rs1 imm))))

;; Length 4: best-len4.s
;; Greenthumb sequence:
;;   1.     xori rd=x2 rs1=x2 imm=5
;;   2.     ori rd=x1 rs1=x2 imm=1
;;   3.     ori rd=x1 rs1=x1 imm=4
;;   4.     xor rd=x1 rs1=x2 rs2=x1
;;(rewrite (Andi rs1 (ImmVal 5))
;;           (Xor (Xori rs1 (ImmVal 5)) (Ori (Ori (Xori rs1 (ImmVal 5)) (ImmVal 1)) (ImmVal 4))))

(rewrite (Andi rs1 imm) 
            (Xor (Xori rs1 imm) (Ori (Xori rs1 imm) imm)))
;; ============================================================
;; OR Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     xori rd=x1 rs1=x2 imm=-1
;;   2.     and rd=x3 rs1=x3 rs2=x1
;;   3.     add rd=x1 rs1=x3 rs2=x2
(rewrite (Or rs1 rs2)
           (Add (And rs2 (Xori rs1 (ImmVal -1))) rs1))

;; Length 5: best-len5.s
;; Greenthumb sequence:
;;   1.     and rd=x1 rs1=x2 rs2=x3
;;   2.     sub rd=x1 rs1=x1 rs2=x3
;;   3.     xori rd=x3 rs1=x3 imm=-1
;;   4.     xori rd=x3 rs1=x0 imm=-1
;;   5.     sub rd=x1 rs1=x2 rs2=x1
(rewrite (Or rs1 rs2)
           (Sub rs1 (Sub (And rs1 rs2) rs2)))

;; ============================================================
;; SLL Rewrites (Greenthumb-generated)
;; ============================================================
;; Length 5: best-len5.s
;; Greenthumb sequence:
;;   1.     add rd=x2 rs1=x2 rs2=x2
;;   2.     add rd=x2 rs1=x2 rs2=x2
;;   3.     add rd=x2 rs1=x2 rs2=x2
;;   4.     add rd=x2 rs1=x2 rs2=x2
;;   5.     add rd=x1 rs1=x2 rs2=x2
(rewrite (Slli rs1 (ImmVal 5))
           (Add (Add (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))) (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1)))) (Add (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))) (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))))))

;; ============================================================
;; XOR Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 4: best-len4.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x3 rs2=x2
;;   2.     and rd=x2 rs1=x2 rs2=x3
;;   3.     xori rd=x2 rs1=x2 imm=-1
;;   4.     and rd=x1 rs1=x2 rs2=x1
(rewrite (Xor rs1 rs2)
           (And (Xori (And rs1 rs2) (ImmVal -1)) (Or rs2 rs1)))

;; Length 4: best-len5.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x3 rs2=x2
;;   2.     and rd=x3 rs1=x3 rs2=x2
;;   3.     sub rd=x1 rs1=x1 rs2=x3
;;   4.     add rd=x2 rs1=x1 rs2=x1
(rewrite (Xor rs1 rs2)
           (Sub (Or rs2 rs1) (And rs2 rs1)))

;; ============================================================
;; MULH Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 18: best-len18.s
;; Greenthumb sequence:
;;   1.     lui rd=x20 imm=16
;;   2.     addi rd=x20 rs1=x20 imm=-1
;;   3.     and rd=x4 rs1=x2 rs2=x20
;;   4.     srai rd=x5 rs1=x2 imm=16
;;   5.     and rd=x6 rs1=x3 rs2=x20
;;   6.     srai rd=x7 rs1=x3 imm=16
;;   7.     mul rd=x8 rs1=x4 rs2=x6
;;   8.     mul rd=x9 rs1=x5 rs2=x6
;;   9.     srli rd=x10 rs1=x8 imm=16
;;   10.     add rd=x9 rs1=x9 rs2=x10
;;   11.     and rd=x11 rs1=x9 rs2=x20
;;   12.     srai rd=x12 rs1=x9 imm=16
;;   13.     mul rd=x13 rs1=x4 rs2=x7
;;   14.     add rd=x11 rs1=x11 rs2=x13
;;   15.     mul rd=x1 rs1=x5 rs2=x7
;;   16.     add rd=x1 rs1=x1 rs2=x12
;;   17.     srai rd=x13 rs1=x11 imm=16
;;   18.     add rd=x1 rs1=x1 rs2=x13
(rewrite (Mulh rs1 rs2)
           (Add (Add (Mul (Srai rs1 (ImmVal 16)) (Srai rs2 (ImmVal 16))) (Srai (Add (Mul (Srai rs1 (ImmVal 16)) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (ImmVal 16))) (Srai (Add (And (Add (Mul (Srai rs1 (ImmVal 16)) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (Srai rs2 (ImmVal 16)))) (ImmVal 16))))

;; ============================================================
;; MULHSU Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 24: best-len25.s
;; Greenthumb sequence:
;;   1.     lui rd=x20 imm=16
;;   2.     addi rd=x20 rs1=x20 imm=-1
;;   3.     and rd=x4 rs1=x2 rs2=x20
;;   4.     srli rd=x5 rs1=x2 imm=16
;;   5.     and rd=x6 rs1=x3 rs2=x20
;;   6.     srli rd=x7 rs1=x3 imm=16
;;   7.     mul rd=x8 rs1=x4 rs2=x6
;;   8.     mul rd=x9 rs1=x4 rs2=x7
;;   9.     mul rd=x10 rs1=x5 rs2=x6
;;   10.     mul rd=x11 rs1=x5 rs2=x7
;;   11.     and rd=x12 rs1=x9 rs2=x20
;;   12.     and rd=x13 rs1=x10 rs2=x20
;;   13.     srli rd=x14 rs1=x8 imm=16
;;   14.     add rd=x15 rs1=x12 rs2=x13
;;   15.     add rd=x15 rs1=x15 rs2=x14
;;   16.     srli rd=x16 rs1=x15 imm=16
;;   17.     srli rd=x17 rs1=x9 imm=16
;;   18.     srli rd=x18 rs1=x10 imm=16
;;   19.     add rd=x1 rs1=x11 rs2=x17
;;   20.     add rd=x1 rs1=x1 rs2=x18
;;   21.     add rd=x1 rs1=x1 rs2=x16
;;   22.     srai rd=x19 rs1=x2 imm=31
;;   23.     and rd=x19 rs1=x19 rs2=x3
;;   24.     sub rd=x1 rs1=x1 rs2=x19
(rewrite (Mulhsu rs1 rs2)
           (Sub (Add (Add (Add (Mul (Srli rs1 (ImmVal 16)) (Srli rs2 (ImmVal 16))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (Srli rs2 (ImmVal 16))) (ImmVal 16))) (Srli (Mul (Srli rs1 (ImmVal 16)) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (Srli (Add (Add (And (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (Srli rs2 (ImmVal 16))) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And (Mul (Srli rs1 (ImmVal 16)) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (ImmVal 16))) (And (Srai rs1 (ImmVal 31)) rs2)))

;; ============================================================
;; MULHU Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 23: best-len24.s
;; Greenthumb sequence:
;;   1.     lui rd=x20 imm=16
;;   2.     addi rd=x20 rs1=x20 imm=-1
;;   3.     and rd=x4 rs1=x2 rs2=x20
;;   4.     srli rd=x5 rs1=x2 imm=16
;;   5.     and rd=x5 rs1=x5 rs2=x20
;;   6.     and rd=x6 rs1=x3 rs2=x20
;;   7.     srli rd=x7 rs1=x3 imm=16
;;   8.     and rd=x7 rs1=x7 rs2=x20
;;   9.     mul rd=x8 rs1=x4 rs2=x6
;;   10.     mul rd=x9 rs1=x4 rs2=x7
;;   11.     mul rd=x10 rs1=x5 rs2=x6
;;   12.     mul rd=x11 rs1=x5 rs2=x7
;;   13.     and rd=x12 rs1=x9 rs2=x20
;;   14.     and rd=x13 rs1=x10 rs2=x20
;;   15.     srli rd=x14 rs1=x8 imm=16
;;   16.     add rd=x15 rs1=x12 rs2=x13
;;   17.     add rd=x15 rs1=x15 rs2=x14
;;   18.     srli rd=x16 rs1=x15 imm=16
;;   19.     srli rd=x17 rs1=x9 imm=16
;;   20.     srli rd=x18 rs1=x10 imm=16
;;   21.     add rd=x1 rs1=x11 rs2=x17
;;   22.     add rd=x1 rs1=x1 rs2=x18
;;   23.     add rd=x1 rs1=x1 rs2=x16
(rewrite (Mulhu rs1 rs2)
           (Add (Add (Add (Mul (And (Srli rs1 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And (Srli rs2 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And (Srli rs2 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (Srli (Mul (And (Srli rs1 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (Srli (Add (Add (And (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And (Srli rs2 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And (Mul (And (Srli rs1 (ImmVal 16)) (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (Srli (Mul (And rs1 (Addi (Lui (ImmVal 16)) (ImmVal -1))) (And rs2 (Addi (Lui (ImmVal 16)) (ImmVal -1)))) (ImmVal 16))) (ImmVal 16))))

;; ============================================================
;; MUL Rewrites using subroutine (Hand-generated)
;; ============================================================
(rewrite (Mul rs1 rs2)
            (CallMul rs1 rs2))

;; ============================================================
;; DIV Rewrites using subroutine (Hand-generated)
;; ============================================================
(rewrite (Div rs1 rs2)
            (CallDiv rs1 rs2))

;; ============================================================
;; DIVU Rewrites using subroutine (Hand-generated)
;; ============================================================
(rewrite (Divu rs1 rs2)
            (CallDivu rs1 rs2))

;; ============================================================
;; REM Rewrites using subroutine (Hand-generated)
;; ============================================================
(rewrite (Rem rs1 rs2)
            (CallRem rs1 rs2))

;; ============================================================
;; REMU Rewrites using subroutine (Hand-generated)
;; ============================================================
(rewrite (Remu rs1 rs2)
            (CallRemu rs1 rs2))