;; ============================================
;; BASE.EGG - Shared RV32IM ISA Definitions
;; ============================================
;; This file contains:
;; 1. Complete RV32IM instruction set definitions
;; 2. Common data types (immediates)
;; 3. Standard rewrite rules for optimization
;; ============================================
;; Note: Registers are declared per-block in SSA form

;; ============================================
;; DATA TYPES
;; ============================================

;; Immediate values
(datatype Imm (ImmVal i64) (ImmLabel String))
;; ============================================
;; RV32I BASE INTEGER INSTRUCTIONS
;; ============================================

(datatype Inst
    ;; === Immediate Instructions (U-type) ===
    (Lui   Imm)               ; rd = imm << 12
    (Auipc Imm)               ; rd = PC + (imm << 12)

    ;; === Jump Instructions ===
    (Jal   Imm)               ; rd = PC + 4; PC = PC + offset
    (Jalr  Inst Imm)          ; rd = PC + 4; PC = (rs1 + offset) & ~1

    ;; === Branch Instructions (B-type) ===
    (Beq   Inst Inst Imm)    ; if (rs1 == rs2) PC += offset
    (Bne   Inst Inst Imm)    ; if (rs1 != rs2) PC += offset
    (Blt   Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (signed)
    (Bge   Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (signed)
    (Bltu  Inst Inst Imm)    ; if (rs1 < rs2) PC += offset (unsigned)
    (Bgeu  Inst Inst Imm)    ; if (rs1 >= rs2) PC += offset (unsigned)

    ;; === Load Instructions (I-type) ===
    (Lb    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][7:0])
    (Lh    Inst Imm)          ; rd = sign_ext(M[rs1 + offset][15:0])
    (Lw    Inst Imm)          ; rd = M[rs1 + offset][31:0]
    (Lbu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][7:0])
    (Lhu   Inst Imm)          ; rd = zero_ext(M[rs1 + offset][15:0])

    ;; === Store Instructions (S-type) ===
    (Sb    Inst Inst Imm)     ; M[rs1 + offset][7:0] = rs2[7:0]
    (Sh    Inst Inst Imm)     ; M[rs1 + offset][15:0] = rs2[15:0]
    (Sw    Inst Inst Imm)     ; M[rs1 + offset][31:0] = rs2[31:0]

    ;; === Register-Immediate Arithmetic/Logical (I-type) ===
    (Addi  Inst Imm)          ; rd = rs1 + imm
    (Slti  Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (signed)
    (Sltiu Inst Imm)          ; rd = (rs1 < imm) ? 1 : 0 (unsigned)
    (Xori  Inst Imm)          ; rd = rs1 ^ imm
    (Ori   Inst Imm)          ; rd = rs1 | imm
    (Andi  Inst Imm)          ; rd = rs1 & imm
    (Slli  Inst Imm)          ; rd = rs1 << shamt
    (Srli  Inst Imm)          ; rd = rs1 >> shamt (logical)
    (Srai  Inst Imm)          ; rd = rs1 >> shamt (arithmetic)

    ;; === Register-Register Arithmetic/Logical (R-type) ===
    (Add   Inst Inst)         ; rd = rs1 + rs2
    (Sub   Inst Inst)         ; rd = rs1 - rs2
    (Sll   Inst Inst)         ; rd = rs1 << rs2[4:0]
    (Slt   Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (signed)
    (Sltu  Inst Inst)         ; rd = (rs1 < rs2) ? 1 : 0 (unsigned)
    (Xor   Inst Inst)         ; rd = rs1 ^ rs2
    (Srl   Inst Inst)         ; rd = rs1 >> rs2[4:0] (logical)
    (Sra   Inst Inst)         ; rd = rs1 >> rs2[4:0] (arithmetic)
    (Or    Inst Inst)         ; rd = rs1 | rs2
    (And   Inst Inst)         ; rd = rs1 & rs2

    ;; === Memory Ordering ===
    (Fence Imm Imm)           ; Memory fence
    (FenceI)                  ; Instruction fence

    ;; === System Instructions ===
    (Ecall)                   ; Environment call
    (Ebreak)                  ; Environment breakpoint
    (Pause)                   ; Pause hint

    ;; ============================================
    ;; RV32M MULTIPLICATION/DIVISION EXTENSION
    ;; ============================================

    (Mul    Inst Inst)        ; rd = (rs1 * rs2)[31:0]
    (Mulh   Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × signed)
    (Mulhsu Inst Inst)        ; rd = (rs1 * rs2)[63:32] (signed × unsigned)
    (Mulhu  Inst Inst)        ; rd = (rs1 * rs2)[63:32] (unsigned × unsigned)
    (Div    Inst Inst)        ; rd = rs1 / rs2 (signed)
    (Divu   Inst Inst)        ; rd = rs1 / rs2 (unsigned)
    (Rem    Inst Inst)        ; rd = rs1 % rs2 (signed)
    (Remu   Inst Inst)        ; rd = rs1 % rs2 (unsigned)

    ;; === Special Values ===
    (LoadImm Imm)             ; Load immediate value
    (RegVal String)           ; Register value reference (takes register name as string)
    (Nop)                     ; No operation

    ;; === Instruction Sequences ===
    ;; Seq2 allows rewriting single instructions as 2-instruction sequences
    ;; Longer sequences can be built by nesting: Seq2(a, Seq2(b, Seq2(c, d)))
    (Seq2 Inst Inst))         ; Sequence of 2 instructions

;; ============================================
;; STANDARD OPTIMIZATION RULES
;; ============================================


;; Shift by zero (immediate versions)
(rewrite (Slli v (ImmVal 0)) v)
(rewrite (Srli v (ImmVal 0)) v)
(rewrite (Srai v (ImmVal 0)) v)

;; === Instruction Decomposition ===

;; Double shifts for larger shift amounts (example for constant propagation)
(rewrite (Slli v (ImmVal 4))
         (Slli (Slli v (ImmVal 2)) (ImmVal 2)))
(rewrite (Slli v (ImmVal 6))
         (Slli (Slli v (ImmVal 3)) (ImmVal 3)))
(rewrite (Srli v (ImmVal 4))
         (Srli (Srli v (ImmVal 2)) (ImmVal 2)))
(rewrite (Srai v (ImmVal 4))
         (Srai (Srai v (ImmVal 2)) (ImmVal 2)))

;; === Load/Store Optimizations ===
;; Decompose byte and halfword loads/stores to use only LW/SW
;; This allows hardware to implement only word-size memory operations

;; Load Byte Signed: LB = LW + sign extension
;; Assumes little-endian, byte 0 at lowest address
(birewrite (Lb base offset)
           (Srai (Slli (Lw base offset) (ImmVal 24)) (ImmVal 24)))

;; Load Byte Unsigned: LBU = LW + mask
(birewrite (Lbu base offset)
           (Andi (Lw base offset) (ImmVal 255)))

;; Load Halfword Signed: LH = LW + sign extension
(birewrite (Lh base offset)
           (Srai (Slli (Lw base offset) (ImmVal 16)) (ImmVal 16)))

;; Load Halfword Unsigned: LHU = LW + mask
(birewrite (Lhu base offset)
           (Andi (Lw base offset) (ImmVal 65535)))

;; Store Word decomposition: SW = 4× SB (simpler than RMW approach)
;; SW stores 4 bytes sequentially using SB (assumes little-endian)
;; Example: SW value, 0(base) = SB byte0; SB byte1; SB byte2; SB byte3
;;
;; Using nested Seq2:
;; (birewrite (Sw base value (ImmVal 0))
;;            (Seq2 (Sb base (Andi value (ImmVal 255)) (ImmVal 0))
;;                  (Seq2 (Sb base (Andi (Srli value (ImmVal 8)) (ImmVal 255)) (ImmVal 1))
;;                        (Seq2 (Sb base (Andi (Srli value (ImmVal 16)) (ImmVal 255)) (ImmVal 2))
;;                              (Sb base (Srli value (ImmVal 24)) (ImmVal 3))))))
;;
;; Store Halfword decomposition: SH = 2× SB
;; (birewrite (Sh base value (ImmVal 0))
;;            (Seq2 (Sb base (Andi value (ImmVal 255)) (ImmVal 0))
;;                  (Sb base (Andi (Srli value (ImmVal 8)) (ImmVal 255)) (ImmVal 1))))
;;
;; Note: Currently commented out - full implementation requires offset arithmetic
;; and would only work for constant offsets (ImmVal), not symbolic (ImmLabel)

;; ============================================
;; I-type Decomposition: Use Only ADDI + R-type
;; ============================================
;; All I-type instructions except ADDI can be implemented using:
;;   - ADDI to load immediate (Addi x0 imm produces the immediate value)
;;   - R-type operation using that value
;; This allows hardware to omit 8 I-type decoders, keeping only ADDI
;;
;; Note: Addi signature is (Addi Inst Imm), so Addi(x0, imm) loads imm

;; XORI rd, rs, imm  =  xor rd, rs, (addi x0, imm)
(birewrite (Xori rs imm)
           (Xor rs (Addi (RegVal "x0") imm)))

;; ANDI rd, rs, imm  =  and rd, rs, (addi x0, imm)
(birewrite (Andi rs imm)
           (And rs (Addi (RegVal "x0") imm)))

;; ORI rd, rs, imm  =  or rd, rs, (addi x0, imm)
(birewrite (Ori rs imm)
           (Or rs (Addi (RegVal "x0") imm)))

;; SLTI rd, rs, imm  =  slt rd, rs, (addi x0, imm)
(birewrite (Slti rs imm)
           (Slt rs (Addi (RegVal "x0") imm)))

;; SLTIU rd, rs, imm  =  sltu rd, rs, (addi x0, imm)
(birewrite (Sltiu rs imm)
           (Sltu rs (Addi (RegVal "x0") imm)))

;; SLLI rd, rs, imm  =  sll rd, rs, (addi x0, imm)
(birewrite (Slli rs imm)
           (Sll rs (Addi (RegVal "x0") imm)))

;; SRLI rd, rs, imm  =  srl rd, rs, (addi x0, imm)
(birewrite (Srli rs imm)
           (Srl rs (Addi (RegVal "x0") imm)))

;; SRAI rd, rs, imm  =  sra rd, rs, (addi x0, imm)
(birewrite (Srai rs imm)
           (Sra rs (Addi (RegVal "x0") imm)))

;; ============================================
;; LUI Decomposition (Commented - Too Complex)
;; ============================================
;; LUI can be eliminated by loading 32-bit constants using shift-and-add sequences
;; Example: Load 0xABCDE000 (LUI loads upper 20 bits, lower 12 are 0)
;;
;; Method: Break constant into chunks, shift and add iteratively
;;   addi sft, x0, 12         ; Shift amount = 12 bits
;;   addi foo, x0, 0xABC      ; Load high 12 bits [31:20]
;;   sll  foo, foo, sft       ; Shift left 12
;;   addi foo, foo, 0xDE0     ; Add middle bits [19:8]
;;   sll  foo, foo, sft       ; Shift left 12 again
;;   addi foo, foo, 0x000     ; Add low bits [7:0]
;;
;; Requires 6 instructions vs 1 LUI (3x cost increase)
;; Pattern would need:
;;   - Constant splitting (can't express in egglog patterns)
;;   - Complex nested Seq2 (5 levels deep)
;;   - Only works for ImmVal, not ImmLabel
;;
;; Alternative: Use constant pool + LW (like ARM)
;;   jal ra, next
;; next: lw rd, const_pool_offset(ra)
;;
;; Conclusion: LUI removal saves very little area, adds significant complexity
;; Recommendation: Keep LUI in hardware

;; ============================================
;; SLT/SLTU Decomposition Using Branches
;; ============================================
;; Set-less-than can be implemented using branch instructions
;; Pattern: Assume true (1), branch-skip-if-true, set false (0)
;;
;; slt a, b, c becomes:
;;   addi a, x0, 1      ; Assume result = 1 (true)
;;   blt b, c, .+4      ; If b < c, skip next instruction
;;   addi a, x0, 0      ; Result = 0 (false, only executed if branch not taken)
;;
;; Uses Seq2 because these are sequential with strict ordering (control flow)

;; SLT rd, rs1, rs2  =  addi tmp, x0, 1; blt rs1, rs2, +4; addi tmp, x0, 0
(birewrite (Slt rs1 rs2)
           (Seq2 (Addi (RegVal "x0") (ImmVal 1))
                 (Seq2 (Blt rs1 rs2 (ImmVal 4))
                       (Addi (RegVal "x0") (ImmVal 0)))))

;; SLTU rd, rs1, rs2  =  addi tmp, x0, 1; bltu rs1, rs2, +4; addi tmp, x0, 0
(birewrite (Sltu rs1 rs2)
           (Seq2 (Addi (RegVal "x0") (ImmVal 1))
                 (Seq2 (Bltu rs1 rs2 (ImmVal 4))
                       (Addi (RegVal "x0") (ImmVal 0)))))

;; === Branch Simplifications ===
;; Branch on same values
(rewrite (Beq v v target) (Jal target))    ; Always taken
(rewrite (Bne v v target) (Nop))           ; Never taken
(rewrite (Blt v v target) (Nop))           ; Never taken
(rewrite (Bge v v target) (Jal target))    ; Always taken
(rewrite (Bltu v v target) (Nop))          ; Never taken (unsigned)
(rewrite (Bgeu v v target) (Jal target))   ; Always taken (unsigned)


;; Expressing signed comparisons in reverse
;; a < b is equivalent to b > a, which is bge b, a, target (with swapped operands)
(rewrite (Blt a b target) (Bge b a target))
;; Similarly for unsigned
(rewrite (Bltu a b target) (Bgeu b a target))

;; === Branch Sequence Rewrites ===
;; These show how branch instructions can be implemented as 2-instruction sequences
;; Both sides are Inst (Seq2 is now an Inst constructor), so no type mismatch
;; Note: Offset is 8 bytes (skip branch itself + jal instruction)

;; beq a, b, target  <==>  bne a, b, 8; jal target
;; "If equal, jump to target" <==> "If not equal, skip next inst; jump to target"
(rewrite (Beq a b target)
           (Seq2 (Bne a b (ImmVal 8)) (Jal target)))

;; bne a, b, target  <==>  beq a, b, 8; jal target
;; "If not equal, jump to target" <==> "If equal, skip next inst; jump to target"
(rewrite (Bne a b target)
           (Seq2 (Beq a b (ImmVal 8)) (Jal target)))

;; blt a, b, target  <==>  bge a, b, 8; jal target
(rewrite (Blt a b target)
           (Seq2 (Bge a b (ImmVal 8)) (Jal target)))

;; bge a, b, target  <==>  blt a, b, 8; jal target
(rewrite (Bge a b target)
           (Seq2 (Blt a b (ImmVal 8)) (Jal target)))

;; bltu a, b, target  <==>  bgeu a, b, 8; jal target
(rewrite (Bltu a b target)
           (Seq2 (Bgeu a b (ImmVal 8)) (Jal target)))

;; bgeu a, b, target  <==>  bltu a, b, 8; jal target
(rewrite (Bgeu a b target)
           (Seq2 (Bltu a b (ImmVal 8)) (Jal target)))

;; === De Morgan's Laws ===
(rewrite (Xori (And a b) (ImmVal -1))
         (Or (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))
(rewrite (Xori (Or a b) (ImmVal -1))
         (And (Xori a (ImmVal -1)) (Xori b (ImmVal -1))))

;; === Distribution (optional - increases expression size) ===
;; Uncomment if needed for specific optimizations
;; (rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
;; (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))  ; factoring

;; === Boolean simplifications ===
(rewrite (And (Or a b) (Or a c))
         (Or a (And b c)))
(rewrite (Or (And a b) (And a c))
         (And a (Or b c)))

;; ============================================================
;; INJECTED GREENTHUMB REWRITE RULES
;; ============================================================

;; ============================================================
;; Greenthumb-Generated Rewrite Rules
;; Auto-generated from riscv_greenthumb synthesis results
;; ============================================================

;; ============================================================
;; ADD Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     sub rd=x2 rs1=x0 rs2=x2
;;   2.     sub rd=x1 rs1=x3 rs2=x2
(birewrite (Add rs1 rs2)
           (Sub rs2 (Sub (RegVal "x0") rs1)))

;; ============================================================
;; ADDI Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     ori rd=x1 rs1=x0 imm=5
;;   2.     add rd=x1 rs1=x2 rs2=x1
(birewrite (Addi rs1 (ImmVal 5))
           (Add rs1 (Ori (RegVal "x0") (ImmVal 5))))

;; ============================================================
;; AND Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x2 rs2=x3
;;   2.     sub rd=x3 rs1=x1 rs2=x3
;;   3.     sub rd=x1 rs1=x2 rs2=x3
(birewrite (And rs1 rs2)
           (Sub rs1 (Sub (Or rs1 rs2) rs2)))

;; ============================================================
;; ANDI Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 2: best-len2.s
;; Greenthumb sequence:
;;   1.     addi rd=x1 rs1=x0 imm=5
;;   2.     and rd=x1 rs1=x1 rs2=x2
(birewrite (Andi rs1 (ImmVal 5))
           (And (Addi (RegVal "x0") (ImmVal 5)) rs1))

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     xori rd=x1 rs1=x2 imm=5
;;   2.     or rd=x2 rs1=x2 rs2=x1
;;   3.     xor rd=x1 rs1=x1 rs2=x2
(birewrite (Andi rs1 (ImmVal 5))
           (Xor (Xori rs1 (ImmVal 5)) (Or rs1 (Xori rs1 (ImmVal 5)))))

;; Length 4: best-len4.s
;; Greenthumb sequence:
;;   1.     xori rd=x2 rs1=x2 imm=5
;;   2.     ori rd=x1 rs1=x2 imm=1
;;   3.     ori rd=x1 rs1=x1 imm=4
;;   4.     xor rd=x1 rs1=x2 rs2=x1
(birewrite (Andi rs1 (ImmVal 5))
           (Xor (Xori rs1 (ImmVal 5)) (Ori (Ori (Xori rs1 (ImmVal 5)) (ImmVal 1)) (ImmVal 4))))

;; ============================================================
;; DIV Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; DIVU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; MUL Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; MULH Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; MULHSU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; MULHU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; OR Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 3: best-len3.s
;; Greenthumb sequence:
;;   1.     xori rd=x1 rs1=x2 imm=-1
;;   2.     and rd=x3 rs1=x3 rs2=x1
;;   3.     add rd=x1 rs1=x3 rs2=x2
(birewrite (Or rs1 rs2)
           (Add (And rs2 (Xori rs1 (ImmVal -1))) rs1))

;; Length 5: best-len5.s
;; Greenthumb sequence:
;;   1.     and rd=x1 rs1=x2 rs2=x3
;;   2.     sub rd=x1 rs1=x1 rs2=x3
;;   3.     xori rd=x3 rs1=x3 imm=-1
;;   4.     xori rd=x3 rs1=x0 imm=-1
;;   5.     sub rd=x1 rs1=x2 rs2=x1
(birewrite (Or rs1 rs2)
           (Sub rs1 (Sub (And rs1 rs2) rs2)))



;; ============================================================
;; REM Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; REMU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SLL Rewrites (Greenthumb-generated)
;; ============================================================
;; Length 5: best-len5.s
;; Greenthumb sequence:
;;   1.     add rd=x2 rs1=x2 rs2=x2
;;   2.     add rd=x2 rs1=x2 rs2=x2
;;   3.     add rd=x2 rs1=x2 rs2=x2
;;   4.     add rd=x2 rs1=x2 rs2=x2
;;   5.     add rd=x1 rs1=x2 rs2=x2
(birewrite (Slli rs1 (ImmVal 5))
           (Add (Add (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))) (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1)))) (Add (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))) (Add (Add (Add rs1 rs1) (Add rs1 rs1)) (Add (Add rs1 rs1) (Add rs1 rs1))))))

;; ============================================================
;; SLT Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SLTI Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SLTIU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SLTU Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SRA Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; SRL Rewrites (Greenthumb-generated)
;; ============================================================

;; ============================================================
;; XOR Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 4: best-len4.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x3 rs2=x2
;;   2.     and rd=x2 rs1=x2 rs2=x3
;;   3.     xori rd=x2 rs1=x2 imm=-1
;;   4.     and rd=x1 rs1=x2 rs2=x1
(birewrite (Xor rs1 rs2)
           (And (Xori (And rs1 rs2) (ImmVal -1)) (Or rs2 rs1)))

;; Length 4: best-len5.s
;; Greenthumb sequence:
;;   1.     or rd=x1 rs1=x3 rs2=x2
;;   2.     and rd=x3 rs1=x3 rs2=x2
;;   3.     sub rd=x1 rs1=x1 rs2=x3
;;   4.     add rd=x2 rs1=x1 rs2=x1
(birewrite (Xor rs1 rs2)
           (Sub (Or rs2 rs1) (And rs2 rs1)))


;; ============================================================
;; MUL Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 191: best-len191.s
;; Greenthumb sequence:
;;   1.     add rd=x1 rs1=x0 rs2=x0
;;   2.     andi rd=x4 rs1=x3 imm=1
;;   3.     sub rd=x5 rs1=x0 rs2=x4
;;   4.     and rd=x6 rs1=x2 rs2=x5
;;   5.     add rd=x1 rs1=x1 rs2=x6
;;   6.     andi rd=x4 rs1=x3 imm=2
;;   7.     srli rd=x4 rs1=x4 imm=1
;;   8.     sub rd=x5 rs1=x0 rs2=x4
;;   9.     slli rd=x6 rs1=x2 imm=1
;;   10.     and rd=x6 rs1=x6 rs2=x5
;;   11.     add rd=x1 rs1=x1 rs2=x6
;;   12.     andi rd=x4 rs1=x3 imm=4
;;   13.     srli rd=x4 rs1=x4 imm=2
;;   14.     sub rd=x5 rs1=x0 rs2=x4
;;   15.     slli rd=x6 rs1=x2 imm=2
;;   16.     and rd=x6 rs1=x6 rs2=x5
;;   17.     add rd=x1 rs1=x1 rs2=x6
;;   18.     andi rd=x4 rs1=x3 imm=8
;;   19.     srli rd=x4 rs1=x4 imm=3
;;   20.     sub rd=x5 rs1=x0 rs2=x4
;;   21.     slli rd=x6 rs1=x2 imm=3
;;   22.     and rd=x6 rs1=x6 rs2=x5
;;   23.     add rd=x1 rs1=x1 rs2=x6
;;   24.     andi rd=x4 rs1=x3 imm=16
;;   25.     srli rd=x4 rs1=x4 imm=4
;;   26.     sub rd=x5 rs1=x0 rs2=x4
;;   27.     slli rd=x6 rs1=x2 imm=4
;;   28.     and rd=x6 rs1=x6 rs2=x5
;;   29.     add rd=x1 rs1=x1 rs2=x6
;;   30.     andi rd=x4 rs1=x3 imm=32
;;   31.     srli rd=x4 rs1=x4 imm=5
;;   32.     sub rd=x5 rs1=x0 rs2=x4
;;   33.     slli rd=x6 rs1=x2 imm=5
;;   34.     and rd=x6 rs1=x6 rs2=x5
;;   35.     add rd=x1 rs1=x1 rs2=x6
;;   36.     andi rd=x4 rs1=x3 imm=64
;;   37.     srli rd=x4 rs1=x4 imm=6
;;   38.     sub rd=x5 rs1=x0 rs2=x4
;;   39.     slli rd=x6 rs1=x2 imm=6
;;   40.     and rd=x6 rs1=x6 rs2=x5
;;   41.     add rd=x1 rs1=x1 rs2=x6
;;   42.     andi rd=x4 rs1=x3 imm=128
;;   43.     srli rd=x4 rs1=x4 imm=7
;;   44.     sub rd=x5 rs1=x0 rs2=x4
;;   45.     slli rd=x6 rs1=x2 imm=7
;;   46.     and rd=x6 rs1=x6 rs2=x5
;;   47.     add rd=x1 rs1=x1 rs2=x6
;;   48.     andi rd=x4 rs1=x3 imm=256
;;   49.     srli rd=x4 rs1=x4 imm=8
;;   50.     sub rd=x5 rs1=x0 rs2=x4
;;   51.     slli rd=x6 rs1=x2 imm=8
;;   52.     and rd=x6 rs1=x6 rs2=x5
;;   53.     add rd=x1 rs1=x1 rs2=x6
;;   54.     andi rd=x4 rs1=x3 imm=512
;;   55.     srli rd=x4 rs1=x4 imm=9
;;   56.     sub rd=x5 rs1=x0 rs2=x4
;;   57.     slli rd=x6 rs1=x2 imm=9
;;   58.     and rd=x6 rs1=x6 rs2=x5
;;   59.     add rd=x1 rs1=x1 rs2=x6
;;   60.     andi rd=x4 rs1=x3 imm=1024
;;   61.     srli rd=x4 rs1=x4 imm=10
;;   62.     sub rd=x5 rs1=x0 rs2=x4
;;   63.     slli rd=x6 rs1=x2 imm=10
;;   64.     and rd=x6 rs1=x6 rs2=x5
;;   65.     add rd=x1 rs1=x1 rs2=x6
;;   66.     andi rd=x4 rs1=x3 imm=2048
;;   67.     srli rd=x4 rs1=x4 imm=11
;;   68.     sub rd=x5 rs1=x0 rs2=x4
;;   69.     slli rd=x6 rs1=x2 imm=11
;;   70.     and rd=x6 rs1=x6 rs2=x5
;;   71.     add rd=x1 rs1=x1 rs2=x6
;;   72.     andi rd=x4 rs1=x3 imm=4096
;;   73.     srli rd=x4 rs1=x4 imm=12
;;   74.     sub rd=x5 rs1=x0 rs2=x4
;;   75.     slli rd=x6 rs1=x2 imm=12
;;   76.     and rd=x6 rs1=x6 rs2=x5
;;   77.     add rd=x1 rs1=x1 rs2=x6
;;   78.     andi rd=x4 rs1=x3 imm=8192
;;   79.     srli rd=x4 rs1=x4 imm=13
;;   80.     sub rd=x5 rs1=x0 rs2=x4
;;   81.     slli rd=x6 rs1=x2 imm=13
;;   82.     and rd=x6 rs1=x6 rs2=x5
;;   83.     add rd=x1 rs1=x1 rs2=x6
;;   84.     andi rd=x4 rs1=x3 imm=16384
;;   85.     srli rd=x4 rs1=x4 imm=14
;;   86.     sub rd=x5 rs1=x0 rs2=x4
;;   87.     slli rd=x6 rs1=x2 imm=14
;;   88.     and rd=x6 rs1=x6 rs2=x5
;;   89.     add rd=x1 rs1=x1 rs2=x6
;;   90.     andi rd=x4 rs1=x3 imm=32768
;;   91.     srli rd=x4 rs1=x4 imm=15
;;   92.     sub rd=x5 rs1=x0 rs2=x4
;;   93.     slli rd=x6 rs1=x2 imm=15
;;   94.     and rd=x6 rs1=x6 rs2=x5
;;   95.     add rd=x1 rs1=x1 rs2=x6
;;   96.     andi rd=x4 rs1=x3 imm=65536
;;   97.     srli rd=x4 rs1=x4 imm=16
;;   98.     sub rd=x5 rs1=x0 rs2=x4
;;   99.     slli rd=x6 rs1=x2 imm=16
;;   100.     and rd=x6 rs1=x6 rs2=x5
;;   101.     add rd=x1 rs1=x1 rs2=x6
;;   102.     andi rd=x4 rs1=x3 imm=131072
;;   103.     srli rd=x4 rs1=x4 imm=17
;;   104.     sub rd=x5 rs1=x0 rs2=x4
;;   105.     slli rd=x6 rs1=x2 imm=17
;;   106.     and rd=x6 rs1=x6 rs2=x5
;;   107.     add rd=x1 rs1=x1 rs2=x6
;;   108.     andi rd=x4 rs1=x3 imm=262144
;;   109.     srli rd=x4 rs1=x4 imm=18
;;   110.     sub rd=x5 rs1=x0 rs2=x4
;;   111.     slli rd=x6 rs1=x2 imm=18
;;   112.     and rd=x6 rs1=x6 rs2=x5
;;   113.     add rd=x1 rs1=x1 rs2=x6
;;   114.     andi rd=x4 rs1=x3 imm=524288
;;   115.     srli rd=x4 rs1=x4 imm=19
;;   116.     sub rd=x5 rs1=x0 rs2=x4
;;   117.     slli rd=x6 rs1=x2 imm=19
;;   118.     and rd=x6 rs1=x6 rs2=x5
;;   119.     add rd=x1 rs1=x1 rs2=x6
;;   120.     andi rd=x4 rs1=x3 imm=1048576
;;   121.     srli rd=x4 rs1=x4 imm=20
;;   122.     sub rd=x5 rs1=x0 rs2=x4
;;   123.     slli rd=x6 rs1=x2 imm=20
;;   124.     and rd=x6 rs1=x6 rs2=x5
;;   125.     add rd=x1 rs1=x1 rs2=x6
;;   126.     andi rd=x4 rs1=x3 imm=2097152
;;   127.     srli rd=x4 rs1=x4 imm=21
;;   128.     sub rd=x5 rs1=x0 rs2=x4
;;   129.     slli rd=x6 rs1=x2 imm=21
;;   130.     and rd=x6 rs1=x6 rs2=x5
;;   131.     add rd=x1 rs1=x1 rs2=x6
;;   132.     andi rd=x4 rs1=x3 imm=4194304
;;   133.     srli rd=x4 rs1=x4 imm=22
;;   134.     sub rd=x5 rs1=x0 rs2=x4
;;   135.     slli rd=x6 rs1=x2 imm=22
;;   136.     and rd=x6 rs1=x6 rs2=x5
;;   137.     add rd=x1 rs1=x1 rs2=x6
;;   138.     andi rd=x4 rs1=x3 imm=8388608
;;   139.     srli rd=x4 rs1=x4 imm=23
;;   140.     sub rd=x5 rs1=x0 rs2=x4
;;   141.     slli rd=x6 rs1=x2 imm=23
;;   142.     and rd=x6 rs1=x6 rs2=x5
;;   143.     add rd=x1 rs1=x1 rs2=x6
;;   144.     andi rd=x4 rs1=x3 imm=16777216
;;   145.     srli rd=x4 rs1=x4 imm=24
;;   146.     sub rd=x5 rs1=x0 rs2=x4
;;   147.     slli rd=x6 rs1=x2 imm=24
;;   148.     and rd=x6 rs1=x6 rs2=x5
;;   149.     add rd=x1 rs1=x1 rs2=x6
;;   150.     andi rd=x4 rs1=x3 imm=33554432
;;   151.     srli rd=x4 rs1=x4 imm=25
;;   152.     sub rd=x5 rs1=x0 rs2=x4
;;   153.     slli rd=x6 rs1=x2 imm=25
;;   154.     and rd=x6 rs1=x6 rs2=x5
;;   155.     add rd=x1 rs1=x1 rs2=x6
;;   156.     andi rd=x4 rs1=x3 imm=67108864
;;   157.     srli rd=x4 rs1=x4 imm=26
;;   158.     sub rd=x5 rs1=x0 rs2=x4
;;   159.     slli rd=x6 rs1=x2 imm=26
;;   160.     and rd=x6 rs1=x6 rs2=x5
;;   161.     add rd=x1 rs1=x1 rs2=x6
;;   162.     andi rd=x4 rs1=x3 imm=134217728
;;   163.     srli rd=x4 rs1=x4 imm=27
;;   164.     sub rd=x5 rs1=x0 rs2=x4
;;   165.     slli rd=x6 rs1=x2 imm=27
;;   166.     and rd=x6 rs1=x6 rs2=x5
;;   167.     add rd=x1 rs1=x1 rs2=x6
;;   168.     andi rd=x4 rs1=x3 imm=268435456
;;   169.     srli rd=x4 rs1=x4 imm=28
;;   170.     sub rd=x5 rs1=x0 rs2=x4
;;   171.     slli rd=x6 rs1=x2 imm=28
;;   172.     and rd=x6 rs1=x6 rs2=x5
;;   173.     add rd=x1 rs1=x1 rs2=x6
;;   174.     andi rd=x4 rs1=x3 imm=536870912
;;   175.     srli rd=x4 rs1=x4 imm=29
;;   176.     sub rd=x5 rs1=x0 rs2=x4
;;   177.     slli rd=x6 rs1=x2 imm=29
;;   178.     and rd=x6 rs1=x6 rs2=x5
;;   179.     add rd=x1 rs1=x1 rs2=x6
;;   180.     andi rd=x4 rs1=x3 imm=1073741824
;;   181.     srli rd=x4 rs1=x4 imm=30
;;   182.     sub rd=x5 rs1=x0 rs2=x4
;;   183.     slli rd=x6 rs1=x2 imm=30
;;   184.     and rd=x6 rs1=x6 rs2=x5
;;   185.     add rd=x1 rs1=x1 rs2=x6
;;   186.     andi rd=x4 rs1=x3 imm=2147483648
;;   187.     srli rd=x4 rs1=x4 imm=31
;;   188.     sub rd=x5 rs1=x0 rs2=x4
;;   189.     slli rd=x6 rs1=x2 imm=31
;;   190.     and rd=x6 rs1=x6 rs2=x5
;;   191.     add rd=x1 rs1=x1 rs2=x6
; (birewrite (Mul rs1 rs2)
;            (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (RegVal "x0") (RegVal "x0")) (And rs1 (Sub (RegVal "x0") (Andi rs2 (ImmVal 1))))) (And (Slli rs1 (ImmVal 1)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 2)) (ImmVal 1))))) (And (Slli rs1 (ImmVal 2)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 4)) (ImmVal 2))))) (And (Slli rs1 (ImmVal 3)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 8)) (ImmVal 3))))) (And (Slli rs1 (ImmVal 4)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 16)) (ImmVal 4))))) (And (Slli rs1 (ImmVal 5)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 32)) (ImmVal 5))))) (And (Slli rs1 (ImmVal 6)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 64)) (ImmVal 6))))) (And (Slli rs1 (ImmVal 7)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 128)) (ImmVal 7))))) (And (Slli rs1 (ImmVal 8)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 256)) (ImmVal 8))))) (And (Slli rs1 (ImmVal 9)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 512)) (ImmVal 9))))) (And (Slli rs1 (ImmVal 10)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 1024)) (ImmVal 10))))) (And (Slli rs1 (ImmVal 11)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 2048)) (ImmVal 11))))) (And (Slli rs1 (ImmVal 12)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 4096)) (ImmVal 12))))) (And (Slli rs1 (ImmVal 13)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 8192)) (ImmVal 13))))) (And (Slli rs1 (ImmVal 14)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 16384)) (ImmVal 14))))) (And (Slli rs1 (ImmVal 15)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 32768)) (ImmVal 15))))) (And (Slli rs1 (ImmVal 16)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 65536)) (ImmVal 16))))) (And (Slli rs1 (ImmVal 17)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 131072)) (ImmVal 17))))) (And (Slli rs1 (ImmVal 18)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 262144)) (ImmVal 18))))) (And (Slli rs1 (ImmVal 19)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 524288)) (ImmVal 19))))) (And (Slli rs1 (ImmVal 20)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 1048576)) (ImmVal 20))))) (And (Slli rs1 (ImmVal 21)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 2097152)) (ImmVal 21))))) (And (Slli rs1 (ImmVal 22)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 4194304)) (ImmVal 22))))) (And (Slli rs1 (ImmVal 23)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 8388608)) (ImmVal 23))))) (And (Slli rs1 (ImmVal 24)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 16777216)) (ImmVal 24))))) (And (Slli rs1 (ImmVal 25)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 33554432)) (ImmVal 25))))) (And (Slli rs1 (ImmVal 26)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 67108864)) (ImmVal 26))))) (And (Slli rs1 (ImmVal 27)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 134217728)) (ImmVal 27))))) (And (Slli rs1 (ImmVal 28)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 268435456)) (ImmVal 28))))) (And (Slli rs1 (ImmVal 29)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 536870912)) (ImmVal 29))))) (And (Slli rs1 (ImmVal 30)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 1073741824)) (ImmVal 30))))) (And (Slli rs1 (ImmVal 31)) (Sub (RegVal "x0") (Srli (Andi rs2 (ImmVal 2147483648)) (ImmVal 31))))))

;; ============================================================
;; MULH Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 19: best-len19.s
;; Greenthumb sequence:
;;   1.     andi rd=x4 rs1=x2 imm=65535
;;   2.     srli rd=x5 rs1=x2 imm=16
;;   3.     andi rd=x6 rs1=x3 imm=65535
;;   4.     srli rd=x7 rs1=x3 imm=16
;;   5.     mul rd=x8 rs1=x4 rs2=x6
;;   6.     mul rd=x9 rs1=x4 rs2=x7
;;   7.     mul rd=x10 rs1=x5 rs2=x6
;;   8.     mul rd=x11 rs1=x5 rs2=x7
;;   9.     srli rd=x12 rs1=x8 imm=16
;;   10.     add rd=x13 rs1=x9 rs2=x10
;;   11.     add rd=x13 rs1=x13 rs2=x12
;;   12.     srli rd=x14 rs1=x13 imm=16
;;   13.     add rd=x1 rs1=x11 rs2=x14
;;   14.     srai rd=x15 rs1=x2 imm=31
;;   15.     srai rd=x16 rs1=x3 imm=31
;;   16.     and rd=x15 rs1=x15 rs2=x3
;;   17.     and rd=x16 rs1=x16 rs2=x2
;;   18.     sub rd=x1 rs1=x1 rs2=x15
;;   19.     sub rd=x1 rs1=x1 rs2=x16
(birewrite (Mulh rs1 rs2)
           (Sub (Sub (Add (Mul (Srli rs1 (ImmVal 16)) (Srli rs2 (ImmVal 16))) (Srli (Add (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16))) (ImmVal 16))) (And (Srai rs1 (ImmVal 31)) rs2)) (And (Srai rs2 (ImmVal 31)) rs1)))

;; ============================================================
;; MULHSU Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 21: best-len21.s
;; Greenthumb sequence:
;;   1.     andi rd=x4 rs1=x2 imm=65535
;;   2.     srli rd=x5 rs1=x2 imm=16
;;   3.     andi rd=x6 rs1=x3 imm=65535
;;   4.     srli rd=x7 rs1=x3 imm=16
;;   5.     mul rd=x8 rs1=x4 rs2=x6
;;   6.     mul rd=x9 rs1=x4 rs2=x7
;;   7.     mul rd=x10 rs1=x5 rs2=x6
;;   8.     mul rd=x11 rs1=x5 rs2=x7
;;   9.     srli rd=x12 rs1=x8 imm=16
;;   10.     add rd=x13 rs1=x9 rs2=x10
;;   11.     sltu rd=x15 rs1=x13 rs2=x9
;;   12.     add rd=x13 rs1=x13 rs2=x12
;;   13.     sltu rd=x16 rs1=x13 rs2=x12
;;   14.     or rd=x17 rs1=x15 rs2=x16
;;   15.     srli rd=x14 rs1=x13 imm=16
;;   16.     add rd=x1 rs1=x11 rs2=x14
;;   17.     slli rd=x17 rs1=x17 imm=16
;;   18.     add rd=x1 rs1=x1 rs2=x17
;;   19.     srai rd=x15 rs1=x2 imm=31
;;   20.     and rd=x15 rs1=x15 rs2=x3
;;   21.     sub rd=x1 rs1=x1 rs2=x15
(birewrite (Mulhsu rs1 rs2)
           (Sub (Add (Add (Mul (Srli rs1 (ImmVal 16)) (Srli rs2 (ImmVal 16))) (Srli (Add (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16))) (ImmVal 16))) (Slli (Or (Sltu (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16)))) (Sltu (Add (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16)))) (ImmVal 16))) (And (Srai rs1 (ImmVal 31)) rs2)))

;; ============================================================
;; MULHU Rewrites (Greenthumb-generated)
;; ============================================================

;; Length 18: best-len18.s
;; Greenthumb sequence:
;;   1.     andi rd=x4 rs1=x2 imm=65535
;;   2.     srli rd=x5 rs1=x2 imm=16
;;   3.     andi rd=x6 rs1=x3 imm=65535
;;   4.     srli rd=x7 rs1=x3 imm=16
;;   5.     mul rd=x8 rs1=x4 rs2=x6
;;   6.     mul rd=x9 rs1=x4 rs2=x7
;;   7.     mul rd=x10 rs1=x5 rs2=x6
;;   8.     mul rd=x11 rs1=x5 rs2=x7
;;   9.     srli rd=x12 rs1=x8 imm=16
;;   10.     add rd=x13 rs1=x9 rs2=x10
;;   11.     sltu rd=x15 rs1=x13 rs2=x9
;;   12.     add rd=x13 rs1=x13 rs2=x12
;;   13.     sltu rd=x16 rs1=x13 rs2=x12
;;   14.     or rd=x17 rs1=x15 rs2=x16
;;   15.     srli rd=x14 rs1=x13 imm=16
;;   16.     add rd=x1 rs1=x11 rs2=x14
;;   17.     slli rd=x17 rs1=x17 imm=16
;;   18.     add rd=x1 rs1=x1 rs2=x17
(birewrite (Mulhu rs1 rs2)
           (Add (Add (Mul (Srli rs1 (ImmVal 16)) (Srli rs2 (ImmVal 16))) (Srli (Add (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16))) (ImmVal 16))) (Slli (Or (Sltu (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16)))) (Sltu (Add (Add (Mul (Andi rs1 (ImmVal 65535)) (Srli rs2 (ImmVal 16))) (Mul (Srli rs1 (ImmVal 16)) (Andi rs2 (ImmVal 65535)))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16))) (Srli (Mul (Andi rs1 (ImmVal 65535)) (Andi rs2 (ImmVal 65535))) (ImmVal 16)))) (ImmVal 16))))
