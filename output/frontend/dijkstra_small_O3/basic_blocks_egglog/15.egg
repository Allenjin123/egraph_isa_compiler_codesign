; EGraph for dijkstra_small_O3 - Block 15
; Total instructions: 28
; Input registers: 4, Output registers: 23

(include "../../../../Saturation/base.egg")

; Input register declarations (used but not defined in this block)
(let a0_0 (RegVal "a0_0"))
(let a1_0 (RegVal "a1_0"))
(let a2_0 (RegVal "a2_0"))
(let ra_0 (RegVal "ra_0"))

; ============================================
; Instruction sequence as a DAG
; ============================================

;; Step 1:     lui rd=t4_0 imm=%hi(qRear)
(let t4_0_val (Lui (ImmLabel "%hi(qRear)")))

;; Step 2:     lw rd=a4_0 rs1=t4_0 imm=%lo(qRear)
(let a4_0_val (Lw t4_0_val (ImmLabel "%lo(qRear)")))

;; Step 3:     lui rd=a5_0 imm=429497
(let a5_0_val (Lui (ImmVal 429497)))

;; Step 4:     addi rd=a5_1 rs1=a5_0 imm=-1107
(let a5_1_val (Addi a5_0_val (ImmVal -1107)))

;; Step 5:     addi rd=a3_0 rs1=a4_0 imm=1
(let a3_0_val (Addi a4_0_val (ImmVal 1)))

;; Step 6:     mulh rd=a5_2 rs1=a3_0 rs2=a5_1
(let a5_2_val (Mulh a3_0_val a5_1_val))

;; Step 7:     srai rd=t5_0 rs1=a3_0 imm=31
(let t5_0_val (Srai a3_0_val (ImmVal 31)))

;; Step 8:     lui rd=t1_0 imm=2
(let t1_0_val (Lui (ImmVal 2)))

;; Step 9:     addi rd=t1_1 rs1=t1_0 imm=1808
(let t1_1_val (Addi t1_0_val (ImmVal 1808)))

;; Step 10:     lui rd=t3_0 imm=%hi(g_qCount)
(let t3_0_val (Lui (ImmLabel "%hi(g_qCount)")))

;; Step 11:     lw rd=a7_0 rs1=t3_0 imm=%lo(g_qCount)
(let a7_0_val (Lw t3_0_val (ImmLabel "%lo(g_qCount)")))

;; Step 12:     slli rd=a6_0 rs1=a4_0 imm=1
(let a6_0_val (Slli a4_0_val (ImmVal 1)))

;; Step 13:     add rd=a6_1 rs1=a6_0 rs2=a4_0
(let a6_1_val (Add a6_0_val a4_0_val))

;; Step 14:     lui rd=a4_1 imm=%hi(queue)
(let a4_1_val (Lui (ImmLabel "%hi(queue)")))

;; Step 15:     slli rd=a6_2 rs1=a6_1 imm=2
(let a6_2_val (Slli a6_1_val (ImmVal 2)))

;; Step 16:     srai rd=a5_3 rs1=a5_2 imm=12
(let a5_3_val (Srai a5_2_val (ImmVal 12)))

;; Step 17:     sub rd=a5_4 rs1=a5_3 rs2=t5_0
(let a5_4_val (Sub a5_3_val t5_0_val))

;; Step 18:     mul rd=a5_5 rs1=a5_4 rs2=t1_1
(let a5_5_val (Mul a5_4_val t1_1_val))

;; Step 19:     addi rd=a4_2 rs1=a4_1 imm=%lo(queue)
(let a4_2_val (Addi a4_1_val (ImmLabel "%lo(queue)")))

;; Step 20:     add rd=a4_3 rs1=a4_2 rs2=a6_2
(let a4_3_val (Add a4_2_val a6_2_val))

;; Step 21:     addi rd=a7_1 rs1=a7_0 imm=1
(let a7_1_val (Addi a7_0_val (ImmVal 1)))

;; Step 22:     sw rs1=a4_3 rs2=a0_0 imm=0
(let inst_21 (Sw a4_3_val a0_0 (ImmVal 0)))

;; Step 23:     sw rs1=a4_3 rs2=a1_0 imm=4
(let inst_22 (Sw a4_3_val a1_0 (ImmVal 4)))

;; Step 24:     sw rs1=a4_3 rs2=a2_0 imm=8
(let inst_23 (Sw a4_3_val a2_0 (ImmVal 8)))

;; Step 25:     sw rs1=t3_0 rs2=a7_1 imm=%lo(g_qCount)
(let inst_24 (Sw t3_0_val a7_1_val (ImmLabel "%lo(g_qCount)")))

;; Step 26:     sub rd=a3_1 rs1=a3_0 rs2=a5_5
(let a3_1_val (Sub a3_0_val a5_5_val))

;; Step 27:     sw rs1=t4_0 rs2=a3_1 imm=%lo(qRear)
(let inst_26 (Sw t4_0_val a3_1_val (ImmLabel "%lo(qRear)")))

;; Step 28:     jalr rd=zero_0 rs1=ra_0 imm=0
(let zero_0_val (Jalr ra_0 (ImmVal 0)))

; ============================================
; Run saturation to apply rewrite rules
; ============================================
(run 3)

; ============================================
; Print eclass IDs for each instruction
; ============================================
(print-eclass-id t4_0_val)
(print-eclass-id a4_0_val)
(print-eclass-id a5_0_val)
(print-eclass-id a5_1_val)
(print-eclass-id a3_0_val)
(print-eclass-id a5_2_val)
(print-eclass-id t5_0_val)
(print-eclass-id t1_0_val)
(print-eclass-id t1_1_val)
(print-eclass-id t3_0_val)
(print-eclass-id a7_0_val)
(print-eclass-id a6_0_val)
(print-eclass-id a6_1_val)
(print-eclass-id a4_1_val)
(print-eclass-id a6_2_val)
(print-eclass-id a5_3_val)
(print-eclass-id a5_4_val)
(print-eclass-id a5_5_val)
(print-eclass-id a4_2_val)
(print-eclass-id a4_3_val)
(print-eclass-id a7_1_val)
(print-eclass-id inst_21)
(print-eclass-id inst_22)
(print-eclass-id inst_23)
(print-eclass-id inst_24)
(print-eclass-id a3_1_val)
(print-eclass-id inst_26)
(print-eclass-id zero_0_val)