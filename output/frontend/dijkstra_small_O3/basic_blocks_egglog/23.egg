; EGraph for dijkstra_small_O3 - Block 23
; Total instructions: 38
; Input registers: 13, Output registers: 24

(include "../../../../Saturation/base.egg")

; Input register declarations (used but not defined in this block)
(let a0_0 (RegVal "a0_0"))
(let a2_0 (RegVal "a2_0"))
(let s1_0 (RegVal "s1_0"))
(let s2_0 (RegVal "s2_0"))
(let s3_0 (RegVal "s3_0"))
(let s4_0 (RegVal "s4_0"))
(let s5_0 (RegVal "s5_0"))
(let s8 (RegVal "s8"))
(let s8_0 (RegVal "s8_0"))
(let s9 (RegVal "s9"))
(let s9_0 (RegVal "s9_0"))
(let sp_0 (RegVal "sp_0"))
(let zero_0 (RegVal "zero_0"))

; ============================================
; Instruction sequence as a DAG
; ============================================

;; Step 1:     sw rs1=sp_0 rs2=s9_0 imm=36
(let inst_0 (Sw sp_0 s9_0 (ImmVal 36)))

;; Step 2:     lui rd=s9_1 imm=%hi(qRear)
(let s9_1_val (Lui (ImmLabel "%hi(qRear)")))

;; Step 3:     lw rd=a1_0 rs1=s9 imm=%lo(qRear)
(let a1_0_val (Lw s9 (ImmLabel "%lo(qRear)")))

;; Step 4:     sw rs1=sp_0 rs2=s2_0 imm=64
(let inst_3 (Sw sp_0 s2_0 (ImmVal 64)))

;; Step 5:     lui rd=s2_1 imm=429497
(let s2_1_val (Lui (ImmVal 429497)))

;; Step 6:     addi rd=a6_0 rs1=a1_0 imm=1
(let a6_0_val (Addi a1_0_val (ImmVal 1)))

;; Step 7:     addi rd=s2_2 rs1=s2_1 imm=-1107
(let s2_2_val (Addi s2_1_val (ImmVal -1107)))

;; Step 8:     mulh rd=a4_0 rs1=a6_0 rs2=s2_2
(let a4_0_val (Mulh a6_0_val s2_2_val))

;; Step 9:     sw rs1=sp_0 rs2=s3_0 imm=60
(let inst_8 (Sw sp_0 s3_0 (ImmVal 60)))

;; Step 10:     srai rd=a7_0 rs1=a6_0 imm=31
(let a7_0_val (Srai a6_0_val (ImmVal 31)))

;; Step 11:     lui rd=s3_1 imm=2
(let s3_1_val (Lui (ImmVal 2)))

;; Step 12:     addi rd=s3_2 rs1=s3_1 imm=1808
(let s3_2_val (Addi s3_1_val (ImmVal 1808)))

;; Step 13:     sw rs1=sp_0 rs2=s8_0 imm=40
(let inst_12 (Sw sp_0 s8_0 (ImmVal 40)))

;; Step 14:     lui rd=s8_1 imm=%hi(g_qCount)
(let s8_1_val (Lui (ImmLabel "%hi(g_qCount)")))

;; Step 15:     lw rd=t0_0 rs1=s8 imm=%lo(g_qCount)
(let t0_0_val (Lw s8 (ImmLabel "%lo(g_qCount)")))

;; Step 16:     slli rd=a5_0 rs1=a1_0 imm=1
(let a5_0_val (Slli a1_0_val (ImmVal 1)))

;; Step 17:     add rd=a5_1 rs1=a5_0 rs2=a1_0
(let a5_1_val (Add a5_0_val a1_0_val))

;; Step 18:     srai rd=a4_1 rs1=a4_0 imm=12
(let a4_1_val (Srai a4_0_val (ImmVal 12)))

;; Step 19:     sub rd=a4_2 rs1=a4_1 rs2=a7_0
(let a4_2_val (Sub a4_1_val a7_0_val))

;; Step 20:     mul rd=a4_3 rs1=a4_2 rs2=s3_2
(let a4_3_val (Mul a4_2_val s3_2_val))

;; Step 21:     lui rd=t2_0 imm=%hi(queue)
(let t2_0_val (Lui (ImmLabel "%hi(queue)")))

;; Step 22:     slli rd=a5_2 rs1=a5_1 imm=2
(let a5_2_val (Slli a5_1_val (ImmVal 2)))

;; Step 23:     addi rd=t2_1 rs1=t2_0 imm=%lo(queue)
(let t2_1_val (Addi t2_0_val (ImmLabel "%lo(queue)")))

;; Step 24:     slli rd=a1_1 rs1=a0_0 imm=3
(let a1_1_val (Slli a0_0 (ImmVal 3)))

;; Step 25:     sw rs1=sp_0 rs2=s1_0 imm=68
(let inst_24 (Sw sp_0 s1_0 (ImmVal 68)))

;; Step 26:     sw rs1=sp_0 rs2=s4_0 imm=56
(let inst_25 (Sw sp_0 s4_0 (ImmVal 56)))

;; Step 27:     add rd=a5_3 rs1=t2_1 rs2=a5_2
(let a5_3_val (Add t2_1_val a5_2_val))

;; Step 28:     add rd=a1_2 rs1=s5_0 rs2=a1_1
(let a1_2_val (Add s5_0 a1_1_val))

;; Step 29:     addi rd=t0_1 rs1=t0_0 imm=1
(let t0_1_val (Addi t0_0_val (ImmVal 1)))

;; Step 30:     sub rd=a4_4 rs1=a6_0 rs2=a4_3
(let a4_4_val (Sub a6_0_val a4_3_val))

;; Step 31:     sw rs1=a5_3 rs2=a0_0 imm=0
(let inst_30 (Sw a5_3_val a0_0 (ImmVal 0)))

;; Step 32:     sw rs1=a5_3 rs2=zero_0 imm=4
(let inst_31 (Sw a5_3_val zero_0 (ImmVal 4)))

;; Step 33:     sw rs1=a5_3 rs2=a2_0 imm=8
(let inst_32 (Sw a5_3_val a2_0 (ImmVal 8)))

;; Step 34:     sw rs1=a1_2 rs2=zero_0 imm=0
(let inst_33 (Sw a1_2_val zero_0 (ImmVal 0)))

;; Step 35:     sw rs1=s9 rs2=a4_4 imm=%lo(qRear)
(let inst_34 (Sw s9 a4_4_val (ImmLabel "%lo(qRear)")))

;; Step 36:     sw rs1=a1_2 rs2=a2_0 imm=4
(let inst_35 (Sw a1_2_val a2_0 (ImmVal 4)))

;; Step 37:     sw rs1=s8 rs2=t0_1 imm=%lo(g_qCount)
(let inst_36 (Sw s8 t0_1_val (ImmLabel "%lo(g_qCount)")))

;; Step 38:     bge rs1=zero_0 rs2=t0_1 imm=.L24
(let inst_37 (Bge zero_0 t0_1_val (ImmLabel ".L24")))

; ============================================
; Run saturation to apply rewrite rules
; Uses natural convergence: stops early if saturated, bounded to 3 attempts
; ============================================
(run-schedule (repeat 3 (saturate (run))))

; ============================================
; Print eclass IDs for each instruction
; ============================================
(print-eclass-id inst_0)
(print-eclass-id s9_1_val)
(print-eclass-id a1_0_val)
(print-eclass-id inst_3)
(print-eclass-id s2_1_val)
(print-eclass-id a6_0_val)
(print-eclass-id s2_2_val)
(print-eclass-id a4_0_val)
(print-eclass-id inst_8)
(print-eclass-id a7_0_val)
(print-eclass-id s3_1_val)
(print-eclass-id s3_2_val)
(print-eclass-id inst_12)
(print-eclass-id s8_1_val)
(print-eclass-id t0_0_val)
(print-eclass-id a5_0_val)
(print-eclass-id a5_1_val)
(print-eclass-id a4_1_val)
(print-eclass-id a4_2_val)
(print-eclass-id a4_3_val)
(print-eclass-id t2_0_val)
(print-eclass-id a5_2_val)
(print-eclass-id t2_1_val)
(print-eclass-id a1_1_val)
(print-eclass-id inst_24)
(print-eclass-id inst_25)
(print-eclass-id a5_3_val)
(print-eclass-id a1_2_val)
(print-eclass-id t0_1_val)
(print-eclass-id a4_4_val)
(print-eclass-id inst_30)
(print-eclass-id inst_31)
(print-eclass-id inst_32)
(print-eclass-id inst_33)
(print-eclass-id inst_34)
(print-eclass-id inst_35)
(print-eclass-id inst_36)
(print-eclass-id inst_37)