#!/usr/bin/env python3
"""
Script to convert .asc file data and append to an existing C file
"""

import os
import re

def append_asc_data_to_c(asc_file, target_c_file, array_name="input_small_data"):
    """
    Read .asc file and append the data as a string array to an existing C file
    Declaration goes before main(), data definition goes at the end
    
    Args:
        asc_file: Path to input .asc file
        target_c_file: Path to existing .c file to modify
        array_name: Name of the C array variable
    """
    # Read the .asc file
    with open(asc_file, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # Get file size
    file_size = len(content)
    
    # Read the existing C file
    with open(target_c_file, 'r', encoding='utf-8') as f:
        c_content = f.read()
    
    # Check if the data declaration already exists and remove it
    if f'extern const char {array_name}[' in c_content or f'const char {array_name}[' in c_content:
        print(f"Warning: {array_name} already exists in {target_c_file}")
        print("Removing old declaration and data...")
        
        # Remove the AUTO-GENERATED section before main()
        pattern = r'/\* ============================================================================\s*\* AUTO-GENERATED DATA FROM.*?\*/\s*' + \
                  r'(?:/\* Forward declaration.*?\*/\s*)?' + \
                  r'(?:extern const char ' + re.escape(array_name) + r'\[.*?\];.*?\n)' + \
                  r'(?:extern const size_t ' + re.escape(array_name) + r'_size;.*?\n)?' + \
                  r'(?:const size_t ' + re.escape(array_name) + r'_size\s*=\s*\d+;.*?\n)?' + \
                  r'\s*'
        c_content = re.sub(pattern, '', c_content, flags=re.DOTALL)
        
        # Remove the data definition at the end
        pattern = r'/\* ============================================================================\s*\* DATA DEFINITION.*?' + \
                  r'const char ' + re.escape(array_name) + r'\[.*?\]\s*=\s*.*?;' + \
                  r'(?:\s*/\*.*?\*/\s*)?' + \
                  r'(?:const size_t ' + re.escape(array_name) + r'_size\s*=\s*\d+;\s*)?'
        c_content = re.sub(pattern, '', c_content, flags=re.DOTALL)
    
    # Find the position before main() function
    main_pattern = r'int main\s*\('
    main_match = re.search(main_pattern, c_content)
    
    if not main_match:
        print("Error: Could not find main() function in the file!")
        return
    
    main_pos = main_match.start()
    
    # Split content at main function
    before_main = c_content[:main_pos]
    main_and_after = c_content[main_pos:]
    
    # Generate the forward declaration (goes before main)
    # Calculate the actual size including null terminator for array declaration
    forward_declaration = f"""
/* ============================================================================
 * AUTO-GENERATED DATA FROM {os.path.basename(asc_file)}
 * File size: {file_size} bytes
 * Generated by: {os.path.basename(__file__)}
 * ============================================================================
 */

/* Forward declaration - data defined at end of file */
extern const char {array_name}[{file_size + 1}];  /* +1 for null terminator */

/* Size defined here directly */
const size_t {array_name}_size = {file_size};

"""
    
    # Generate the data definition (goes at end of file)
    data_definition_header = f"""
/* ============================================================================
 * DATA DEFINITION
 * ============================================================================
 */

const char {array_name}[{file_size + 1}] = """
    
    # Split content into chunks for readability (80 chars per line)
    chunk_size = 80
    chunks = []
    
    for i in range(0, len(content), chunk_size):
        chunk = content[i:i+chunk_size]
        # Escape special characters
        escaped_chunk = chunk.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        chunks.append(f'    "{escaped_chunk}"')
    
    # Generate the size definition with direct assignment
    size_definition = f""";
"""
    
    # Write the modified file
    with open(target_c_file, 'w', encoding='utf-8') as f:
        f.write(before_main)
        f.write(forward_declaration)
        f.write(main_and_after)
        f.write(data_definition_header)
        f.write('\n'.join(chunks))
        f.write('\n' + size_definition)
    
    print(f"✓ Appended data from {asc_file} to {target_c_file}")
    print(f"  Data size: {file_size} bytes")
    print(f"  Array name: {array_name}[{file_size + 1}]")
    print(f"  Size variable: {array_name}_size = {file_size}")
    print(f"  Declaration added before main()")
    print(f"  Data definition at end of file ({len(chunks)} lines)")

def convert_asc_to_c(asc_file, output_c_file, array_name="input_data"):
    """
    Read .asc file and generate a standalone C file with the data as a string array
    
    Args:
        asc_file: Path to input .asc file
        output_c_file: Path to output .c file
        array_name: Name of the C array variable
    """
    # Read the .asc file
    with open(asc_file, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # Get file size
    file_size = len(content)
    
    # Generate C file header
    c_header = f"""/* Auto-generated from {os.path.basename(asc_file)} */
/* File size: {file_size} bytes */

#include <stddef.h>

/* Input data array */
const char {array_name}[] = """
    
    # Split content into chunks for readability (80 chars per line)
    chunk_size = 80
    chunks = []
    
    for i in range(0, len(content), chunk_size):
        chunk = content[i:i+chunk_size]
        # Escape special characters
        escaped_chunk = chunk.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        chunks.append(f'    "{escaped_chunk}"')
    
    # Generate C file footer
    c_footer = f""";

/* Size of the input data */
const size_t {array_name}_size = sizeof({array_name}) - 1;  /* -1 to exclude null terminator */
"""
    
    # Write the C file
    with open(output_c_file, 'w', encoding='utf-8') as f:
        f.write(c_header)
        f.write('\n'.join(chunks))
        f.write('\n' + c_footer)
    
    print(f"✓ Converted {asc_file} -> {output_c_file}")
    print(f"  Data size: {file_size} bytes")
    print(f"  Array name: {array_name}")
    print(f"  Lines in C file: {len(chunks) + 10}")


if __name__ == "__main__":
    import sys
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    asc_file = os.path.join(script_dir, "input_small.asc")
    
    if not os.path.exists(asc_file):
        print(f"Error: {asc_file} not found!")
        exit(1)
    
    # Check command line arguments
    if len(sys.argv) > 1 and sys.argv[1] == '--append':
        # Append mode: add data to existing aesxam.c
        target_file = os.path.join(script_dir, "aesxam.c")
        if not os.path.exists(target_file):
            print(f"Error: {target_file} not found!")
            exit(1)
        
        append_asc_data_to_c(asc_file, target_file, "input_small_data")
        print(f"\nModified: {target_file}")
    else:
        # Standalone mode: create separate .c file
        output_file = os.path.join(script_dir, "input_small_data.c")
        convert_asc_to_c(asc_file, output_file, "input_small_data")
        print(f"\nGenerated C file: {output_file}")
        print("\nTo append to aesxam.c instead, run:")
        print(f"  python3 {__file__} --append")

