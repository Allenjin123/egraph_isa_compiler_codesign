#!/usr/bin/env python3
"""
Script to convert .asc file data and append to an existing C file
"""

import argparse
import os
import re

def append_asc_data_to_c(asc_file, target_c_file, array_name="input_small_data"):
    """
    Read .asc file and append the data as a string array to an existing C file
    Declaration goes before main(), data definition goes at the end
    
    Args:
        asc_file: Path to input .asc file
        target_c_file: Path to existing .c file to modify
        array_name: Name of the C array variable
    """
    # Read the .asc file
    with open(asc_file, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # Get file size
    file_size = len(content)
    
    # Read the existing C file
    with open(target_c_file, 'r', encoding='utf-8') as f:
        c_content = f.read()
    
    # Check if the data declaration already exists and remove it
    if f'extern const char {array_name}[' in c_content or f'const char {array_name}[' in c_content:
        print(f"Warning: {array_name} already exists in {target_c_file}")
        print("Removing old declaration and data...")
        
        # Remove the AUTO-GENERATED section before main()
        pattern = r'/\* ============================================================================\s*\* AUTO-GENERATED DATA FROM.*?\*/\s*' + \
                  r'(?:/\* Forward declaration.*?\*/\s*)?' + \
                  r'(?:extern const char ' + re.escape(array_name) + r'\[.*?\];.*?\n)' + \
                  r'(?:extern const size_t ' + re.escape(array_name) + r'_size;.*?\n)?' + \
                  r'(?:const size_t ' + re.escape(array_name) + r'_size\s*=\s*\d+;.*?\n)?' + \
                  r'\s*'
        c_content = re.sub(pattern, '', c_content, flags=re.DOTALL)
        
        # Remove the data definition at the end
        pattern = r'/\* ============================================================================\s*\* DATA DEFINITION.*?' + \
                  r'const char ' + re.escape(array_name) + r'\[.*?\]\s*=\s*.*?;' + \
                  r'(?:\s*/\*.*?\*/\s*)?' + \
                  r'(?:const size_t ' + re.escape(array_name) + r'_size\s*=\s*\d+;\s*)?'
        c_content = re.sub(pattern, '', c_content, flags=re.DOTALL)
    
    # Find the position before main() function
    main_pattern = r'int main\s*\('
    main_match = re.search(main_pattern, c_content)
    
    if not main_match:
        print("Error: Could not find main() function in the file!")
        return
    
    main_pos = main_match.start()
    
    # Split content at main function
    before_main = c_content[:main_pos]
    main_and_after = c_content[main_pos:]
    
    # Generate the forward declaration (goes before main)
    # Calculate the actual size including null terminator for array declaration
    forward_declaration = f"""
/* ============================================================================
 * AUTO-GENERATED DATA FROM {os.path.basename(asc_file)}
 * File size: {file_size} bytes
 * Generated by: {os.path.basename(__file__)}
 * ============================================================================
 */

/* Forward declaration - data defined at end of file */
extern const char {array_name}[{file_size + 1}];  /* +1 for null terminator */

/* Size defined here directly */
const size_t {array_name}_size = {file_size};

"""
    
    # Generate the data definition (goes at end of file)
    data_definition_header = f"""
/* ============================================================================
 * DATA DEFINITION
 * ============================================================================
 */

const char {array_name}[{file_size + 1}] = """
    
    # Split content into chunks for readability (80 chars per line)
    chunk_size = 80
    chunks = []
    
    for i in range(0, len(content), chunk_size):
        chunk = content[i:i+chunk_size]
        # Escape special characters
        escaped_chunk = chunk.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        chunks.append(f'    "{escaped_chunk}"')
    
    # Generate the size definition with direct assignment
    size_definition = f""";
"""
    
    # Write the modified file
    with open(target_c_file, 'w', encoding='utf-8') as f:
        f.write(before_main)
        f.write(forward_declaration)
        f.write(main_and_after)
        f.write(data_definition_header)
        f.write('\n'.join(chunks))
        f.write('\n' + size_definition)
    
    print(f"✓ Appended data from {asc_file} to {target_c_file}")
    print(f"  Data size: {file_size} bytes")
    print(f"  Array name: {array_name}[{file_size + 1}]")
    print(f"  Size variable: {array_name}_size = {file_size}")
    print(f"  Declaration added before main()")
    print(f"  Data definition at end of file ({len(chunks)} lines)")

def convert_asc_to_c(asc_file, output_c_file, array_name="input_data"):
    """
    Read .asc file and generate a standalone C file with the data as a string array
    
    Args:
        asc_file: Path to input .asc file
        output_c_file: Path to output .c file
        array_name: Name of the C array variable
    """
    # Read the .asc file
    with open(asc_file, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()
    
    # Get file size
    file_size = len(content)
    
    # Generate C file header
    c_header = f"""/* Auto-generated from {os.path.basename(asc_file)} */
/* File size: {file_size} bytes */

#include <stddef.h>

/* Input data array */
const char {array_name}[] = """
    
    # Split content into chunks for readability (80 chars per line)
    chunk_size = 80
    chunks = []
    
    for i in range(0, len(content), chunk_size):
        chunk = content[i:i+chunk_size]
        # Escape special characters
        escaped_chunk = chunk.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
        chunks.append(f'    "{escaped_chunk}"')
    
    # Generate C file footer
    c_footer = f""";

/* Size of the input data */
const size_t {array_name}_size = sizeof({array_name}) - 1;  /* -1 to exclude null terminator */
"""
    
    # Write the C file
    with open(output_c_file, 'w', encoding='utf-8') as f:
        f.write(c_header)
        f.write('\n'.join(chunks))
        f.write('\n' + c_footer)
    
    print(f"✓ Converted {asc_file} -> {output_c_file}")
    print(f"  Data size: {file_size} bytes")
    print(f"  Array name: {array_name}")
    print(f"  Lines in C file: {len(chunks) + 10}")


def build_parser() -> argparse.ArgumentParser:
    script_dir = os.path.dirname(os.path.abspath(__file__))

    parser = argparse.ArgumentParser(
        description="将 .asc 文本数据转为 C 字符数组，支持直接生成独立 C 文件或追加到已有目标文件。"
    )
    parser.add_argument(
        "--asc-file",
        default=os.path.join(script_dir, "input_small.asc"),
        help="输入的 .asc 文件路径（默认：脚本同目录下的 input_small.asc）",
    )
    parser.add_argument(
        "--array-name",
        default="input_small_data",
        help="生成的 C 数组名称（默认：input_small_data）",
    )
    parser.add_argument(
        "--append",
        action="store_true",
        help="以追加模式运行，将数据插入到目标 C 文件（默认：关闭，生成独立 C 文件）",
    )
    parser.add_argument(
        "--target-c-file",
        default=os.path.join(script_dir, "aesxam.c"),
        help="当使用 --append 时，要写入的目标 C 文件（默认：脚本同目录下的 aesxam.c）",
    )
    parser.add_argument(
        "--output-c-file",
        default=os.path.join(script_dir, "input_small_data.c"),
        help="当未使用 --append 时，输出的 C 文件路径（默认：脚本同目录生成 input_small_data.c）",
    )
    return parser


if __name__ == "__main__":
    parser = build_parser()
    args = parser.parse_args()

    asc_file = os.path.abspath(args.asc_file)
    array_name = args.array_name

    if not os.path.exists(asc_file):
        print(f"Error: {asc_file} not found!")
        exit(1)

    if args.append:
        target_c_file = os.path.abspath(args.target_c_file)
        if not os.path.exists(target_c_file):
            print(f"Error: {target_c_file} not found!")
            exit(1)

        append_asc_data_to_c(asc_file, target_c_file, array_name)
        print(f"\nModified: {target_c_file}")
    else:
        output_c_file = os.path.abspath(args.output_c_file)
        convert_asc_to_c(asc_file, output_c_file, array_name)
        print(f"\nGenerated C file: {output_c_file}")

